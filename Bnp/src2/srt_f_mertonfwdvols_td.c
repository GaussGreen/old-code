/******************************************************************************
Computes the forward smile generated by a Jump model

Authors: Ezra Nahum
                 Yann Samuelides



********************************************************************************/

#include "math.h"
#include "num_h_allhdr.h"
#include "num_h_hermite.h"
#include "num_h_levenberg.h"
#include "srt_h_all.h"
#include "srt_h_resetable.h"
#include "swp_h_cms.h"
#include <opfnctns.h"
#include <swp_h_all.h"
#include <swp_h_external_fct.h"
#include <swp_h_vol.h"
#include <utallhdr.H>
#define NMAXSTRIKES 10

/*Free Memory Function*/

Err FREE_TD(int n_resetdates, int intindex, double **paramatrix,
            double *brownian, double *jumps1, double *jumps2,
            double *paramsmiledate, double *periodmat) {
  if (paramatrix)
    free_dmatrix(paramatrix, 1, n_resetdates, 1, 5 * n_resetdates);
  paramatrix = NULL;

  if (brownian)
    free_dvector(brownian, 1, n_resetdates);
  brownian = NULL;

  if (jumps1)
    free_dvector(jumps1, 1, n_resetdates);
  jumps1 = NULL;

  if (jumps2)
    free_dvector(jumps2, 1, n_resetdates);
  jumps2 = NULL;

  if (paramsmiledate)
    free_dvector(paramsmiledate, 1, 5 * (intindex + 1));
  paramsmiledate = NULL;

  if (periodmat)
    free_dvector(periodmat, 1, n_resetdates);
  periodmat = NULL;

  return NULL;
}

Err calibtosmilefwdvols(long today, long dDate, char *cMarketId,
                        char *szVolCurveName, char *cRefRateCode,
                        char *szYieldCurveName, double *param, long *ia);

/* Function which calculates the value of a Fra */

Err get_fra(long Fradate, int spotlag, char *cRefRateCode,
            char *szYieldCurveName, double *dFra);

/* Function which calibrates the parameters of the jump model to a caplet smile
corresponding to a specific maturity date */

Err calibtosmilefwdvols_td(long today, long dDate, char *cMarketId,
                           char *szVolCurveName, char *cRefRateCode,
                           char *szYieldCurveName, int nperiods, double *param,
                           double *mat, long *ia) {
  Err err = NULL;
  int i;
  int spotlag;
  double atmvol;
  double lognorm = 1.0;
  long dDatespot, dDatespot3;
  double Strikeinf, Strikesup;
  double totalmat;
  double dFra;
  double Strikespread;
  double *strikes;
  double *vols;
  double *calibvols;
  double s;
  int num_of_months;
  double chisq;
  SrtCrvPtr yldcrv;
  SrtBasisCode float_basis;
  SrtCompounding float_compounding;

  yldcrv = lookup_curve(szYieldCurveName);
  spotlag = get_spotlag_from_curve(yldcrv);

  /*Memory Allocation*/

  strikes = dvector(1, NMAXSTRIKES + 1);
  vols = dvector(1, NMAXSTRIKES + 1);
  calibvols = dvector(1, NMAXSTRIKES + 1);

  /* get info from the RefRate Code*/
  if (err = swp_f_get_ref_rate_details(cRefRateCode, &float_basis,
                                       &float_compounding)) {
    smessage("Error if swp_f_get_ref_rate_details");
  }

  num_of_months = 12 / float_compounding;

  /* We now get the strikes and the vols of the smile we will calibrate on*/

  err = get_fra(dDate, spotlag, cRefRateCode, szYieldCurveName, &dFra);

  dDatespot = add_unit(dDate, spotlag, SRT_BDAY, MODIFIED_SUCCEEDING);

  dDatespot3 =
      add_unit(dDatespot, num_of_months, SRT_MONTH, MODIFIED_SUCCEEDING);

  if (err = swp_f_vol(szVolCurveName, (double)dDatespot, (double)dDatespot3,
                      dFra, &atmvol, &lognorm)) {
    smessage("Error in swp_f_vol");
  }

  totalmat = (dDate - today) / 365.0;

  Strikeinf = dFra - 2 * atmvol * dFra * sqrt(totalmat);
  Strikesup = dFra + 2 * atmvol * dFra * sqrt(totalmat);
  Strikespread = (Strikesup - Strikeinf) / NMAXSTRIKES;

  s = Strikeinf;
  i = 1;

  while (s <= Strikesup) {
    strikes[i] = s;

    if (err = swp_f_vol(szVolCurveName, (double)dDatespot, (double)dDatespot3,
                        s, &(vols[i]), &lognorm)) {
      smessage("Error in swp_f_vol");
    }

    i++;
    s = s + Strikespread;
  }

  /* call the function which calibrates the Merton model to a given smile */
  err = optcalibmertontimedep(dFra, NMAXSTRIKES, nperiods, strikes, vols, param,
                              mat, "Lognormal", &chisq, ia, calibvols);

  /*free memory*/

  free_dvector(strikes, 1, NMAXSTRIKES + 1);
  free_dvector(vols, 1, NMAXSTRIKES + 1);
  free_dvector(calibvols, 1, NMAXSTRIKES + 1);

  return err;
}

/* General calibration function which calibrates the parameters to the smiles of
the resetdates of the resetable as well as the smile of the end date of the
product (going from the longer maturity to the shorter one)*/

Err resetablecalibfwdvols_td(long today, int n_resetdates, double *resetdates,
                             char *cMarketId, char *szVolCurveName,
                             char *cRefRateCode, char *szYieldCurveName,
                             double *paraminitguess, double **paramatrix)

{
  Err err = NULL;
  int i, j;
  long *freeze;
  double *mat;
  double *startparam; /*first: calibration to the longest maturity*/

  /*memory allocation*/
  freeze = lngvector(1, 5 * n_resetdates);
  mat = dvector(1, n_resetdates);
  startparam = dvector(1, 5);

  mat[1] = (resetdates[1] - today) / 365.0;
  for (i = 2; i <= n_resetdates; i++) {
    mat[i] = (resetdates[i] - resetdates[i - 1]) / 365.0;
  }

  for (i = 1; i <= 5; i++) {
    freeze[i] = 1;
    startparam[i] = paraminitguess[i];
  }

  /*freeze the intensities of the jumps and the parameters that are determined
   * by the stationarity assumption*/
  freeze[3] = 0;
  freeze[5] = 0;
  for (i = 6; i <= 5 * n_resetdates; i++) {
    freeze[i] = 0;
  }

  /* now calibrates the  first smile */

  for (i = 1; i <= 5; i++) {
    paramatrix[1][i] = startparam[i];
  }

  err = calibtosmilefwdvols(today, (long)resetdates[1], cMarketId,
                            szVolCurveName, cRefRateCode, szYieldCurveName,
                            paramatrix[1], freeze);

  for (j = 2; j <= n_resetdates; j++) {

    for (i = 1; i <= 5; i++) {
      paramatrix[j][i] = startparam[i];
    }

    for (i = 6; i <= 5 * j; i++) {
      paramatrix[j][i] = paramatrix[j - 1][i - 5];
    }

    err = calibtosmilefwdvols_td(today, (long)resetdates[j], cMarketId,
                                 szVolCurveName, cRefRateCode, szYieldCurveName,
                                 j, paramatrix[j], mat, freeze);
  }

  /* free memory */

  free_lngvector(freeze, 1, 5 * n_resetdates);
  free_dvector(mat, 1, n_resetdates);
  free_dvector(startparam, 1, 5);
  return err;
}

/* Gets the DRS value for each fixing day within a period */

Err get_DRStsfwdvols_td(long today, double smiledate, char *cRefRateCode,
                        char *szYieldCurveName, double *DRSts) {
  Err err = NULL;
  long FraSpot;
  double num_of_months;
  double maturity;
  int spotlag;
  double dFra;
  SrtBasisCode float_basis;
  SrtCompounding float_compounding;
  SrtCrvPtr yldcrv;

  yldcrv = lookup_curve(szYieldCurveName);
  spotlag = get_spotlag_from_curve(yldcrv);

  /* start date of the Fra*/
  FraSpot = add_unit((long)smiledate, spotlag, SRT_BDAY, MODIFIED_SUCCEEDING);

  /*Get details for the index Fra*/
  if (err = swp_f_get_ref_rate_details(cRefRateCode, &float_basis,
                                       &float_compounding)) {
    smessage("Error in swp_f_get_ref_rate_details");
  }

  num_of_months = 12 / float_compounding;

  maturity = coverage(today, (long)smiledate, BASIS_ACT_365);

  /* compute the fra */

  err =
      get_fra((long)smiledate, spotlag, cRefRateCode, szYieldCurveName, &dFra);

  *DRSts = dFra;

  return err;
}

/* Using the Merton diffusion with fixed parameters  , computes the value of a
DRs corresponding to the solution of the SDE it satisfies*/
Err DRSCalcfwdvols_td(double *brownian, double *jumps1, double *jumps2,
                      int index, double *periodmat, double *param,
                      double *DRSts) {

  Err err = NULL;

  int j;

  for (j = 1; j <= index + 1; j++) {

    *DRSts *=
        exp(-param[5 * (j - 1) + 1] * param[5 * (j - 1) + 1] * periodmat[j] /
                2 +
            param[5 * (j - 1) + 1] * brownian[j] * sqrt(periodmat[j])) *
        exp(jumps1[j] * log(1 + param[5 * (j - 1) + 2]) -
            param[5 * (j - 1) + 3] * param[5 * (j - 1) + 2] * periodmat[j]) *
        exp(jumps2[j] * log(1 + param[5 * (j - 1) + 4]) -
            param[5 * (j - 1) + 5] * param[5 * (j - 1) + 4] * periodmat[j]);
  }

  return err;
}

/* Main function*/

Err srt_f_mertonfwdvols_td(int seedo, double smiledate, int n_resetdates,
                           double *resetdates, int n_strikes, double *strikes,
                           double *initparam, char *cRefRateCode,
                           char *cMarketId, char *szYieldCurveName,
                           char *szVolCurveName, double *res)

{
  Err err = NULL;
  int j;
  double **paramatrix;
  double DRSts, DRStsStart;
  int spotlag;
  double *impvols;
  double *periodmat;
  double *jumps1;
  double *jumps2;
  double *brownian;
  double exp1, exp2;
  double *paramsmiledate;
  double *paramleftout;
  long today;
  long idum;
  int intindex;

  SrtBasisCode float_basis;
  SrtCompounding float_compounding;
  SrtCrvPtr yldcrv;

  yldcrv = lookup_curve(szYieldCurveName);
  today = get_today_from_curve(yldcrv);
  spotlag = get_spotlag_from_curve(yldcrv);

  /*uniform*/
  idum = -seedo;
  uniform(&idum);
  intindex = 0;
  /*Get details for the index Fra*/
  if (err = swp_f_get_ref_rate_details(cRefRateCode, &float_basis,
                                       &float_compounding)) {
    smessage("Error in swp_f_get_ref_rate_details");
  }

  /*recognizes in which interval the smiledate is*/
  for (j = 1; j <= n_resetdates - 1; j++) {
    if (smiledate >= resetdates[j]) {
      intindex++;
    }
  }

  /*memory allocation*/
  paramatrix = dmatrix(1, n_resetdates, 1, 5 * n_resetdates);
  brownian = dvector(1, n_resetdates);
  jumps1 = dvector(1, n_resetdates);
  jumps2 = dvector(1, n_resetdates);
  paramsmiledate = dvector(1, 5 * (intindex + 1));
  periodmat = dvector(1, n_resetdates);
  paramleftout = dvector(1, 5);
  /* calibrate the parameters to the caplets smiles of the resetdates and end
   * date */

  err = resetablecalibfwdvols_td(today, n_resetdates, resetdates, cMarketId,
                                 szVolCurveName, cRefRateCode, szYieldCurveName,
                                 initparam, paramatrix);
  if (err) {
    FREE_TD(n_resetdates, intindex, paramatrix, brownian, jumps1, jumps2,
            paramsmiledate, periodmat);

    return err;
  }

  /*memory allocation*/
  impvols = dvector(1, n_strikes);

  err = get_DRStsfwdvols_td(today, smiledate, cRefRateCode, szYieldCurveName,
                            &DRStsStart);

  if (err) {
    FREE_TD(n_resetdates, intindex, paramatrix, brownian, jumps1, jumps2,
            paramsmiledate, periodmat);
    return err;
  }

  /* get parameters corresponding to the smiledate   , with an interpolation for
   * the first part of the diffusion*/

  paramsmiledate[1] =
      paramatrix[intindex][1] +
      (smiledate - resetdates[intindex]) *
          (paramatrix[intindex + 1][1] - paramatrix[intindex][1]) /
          (resetdates[intindex + 1] - resetdates[intindex]);
  paramsmiledate[2] =
      paramatrix[intindex][2] +
      (smiledate - resetdates[intindex]) *
          (paramatrix[intindex + 1][2] - paramatrix[intindex][2]) /
          (resetdates[intindex + 1] - resetdates[intindex]);
  paramsmiledate[3] = paramatrix[intindex][3];
  paramsmiledate[4] =
      paramatrix[intindex][4] +
      (smiledate - resetdates[intindex]) *
          (paramatrix[intindex + 1][4] - paramatrix[intindex][4]) /
          (resetdates[intindex + 1] - resetdates[intindex]);
  paramsmiledate[5] = paramatrix[intindex][5];

  for (j = 6; j <= 5 * (intindex + 1); j++) {
    paramsmiledate[j] = paramatrix[intindex + 1][j];
  }

  for (j = 1; j <= 5; j++) {
    paramleftout[j] = paramsmiledate[5 * (intindex) + j];
  }

  DRSts = DRStsStart;

  /*get the simulated Brownians and Poissons*/
  periodmat[1] = (smiledate - resetdates[intindex]) / 365.0;
  periodmat[2] = (resetdates[1] - today) / 365.0;
  for (j = 3; j <= n_resetdates; j++) {
    periodmat[j] = (resetdates[j - 1] - resetdates[j - 2]) / 365.0;
  }

  for (j = 1; j <= n_resetdates; j++) {

    brownian[j] = inv_cumnorm_fast(uniform(&idum));
    exp1 = -log(uniform(&idum)) / paramsmiledate[3];
    exp2 = -log(uniform(&idum)) / paramsmiledate[5];

    while (exp1 < periodmat[j]) {
      exp1 += -log(uniform(&idum)) / paramsmiledate[3];
      jumps1[j]++;
    }

    while (exp1 < periodmat[j]) {
      exp2 += -log(uniform(&idum)) / paramsmiledate[5];
      jumps2[j]++;
    }
  }

  err = DRSCalcfwdvols_td(brownian, jumps1, jumps2, intindex, periodmat,
                          paramsmiledate, &DRSts);

  if (err) {
    FREE_TD(n_resetdates, intindex, paramatrix, brownian, jumps1, jumps2,
            paramsmiledate, periodmat);
    return err;
  }

  optmertonsmile(DRSts, n_strikes, strikes, paramleftout, periodmat[1],
                 "Lognormal", impvols);

  res[1] = DRSts;

  for (j = 1; j <= n_strikes; j++) {
    res[j + 1] = impvols[j];
  }

  FREE_TD(n_resetdates, intindex, paramatrix, brownian, jumps1, jumps2,
          paramsmiledate, periodmat);
  free_dvector(impvols, 1, n_strikes);
  free_dvector(paramleftout, 1, 5);
  return err;
}
