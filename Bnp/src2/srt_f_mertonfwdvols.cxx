/******************************************************************************
Computes the forward smile generated by a Jump model

Authors: Ezra Nahum
                 Yann Samuelides



********************************************************************************/

#include "math.h"
#include "num_h_allhdr.h"
#include "num_h_hermite.h"
#include "num_h_levenberg.h"
#include "srt_h_all.h"
#include "srt_h_resetable.h"
#include "swp_h_cms.h"
#include <opfnctns.h"
#include <swp_h_all.h"
#include <swp_h_external_fct.h"
#include <swp_h_vol.h"
#include <utallhdr.H>
#define NMAXSTRIKES 10

/*Free Memory functions*/

Err free_resetableperiodfwdvols(double **paramperiod, double *periodmat,
                                double *DRStsStart, double *DRSts,
                                double *driftbefore, double *driftafter)

{
  if (paramperiod)
    free_dmatrix(paramperiod, 1, 3, 1, 5);
  paramperiod = NULL;

  if (periodmat)
    free_dvector(periodmat, 1, 3);
  periodmat = NULL;

  if (DRSts)
    free_dvector(DRSts, 1, 3);
  DRSts = NULL;

  if (DRStsStart)
    free_dvector(DRSts, 1, 3);
  DRStsStart = NULL;

  if (driftbefore)
    free_dvector(driftbefore, 1, 3);
  driftbefore = NULL;

  if (driftafter)
    free_dvector(driftafter, 1, 3);
  driftafter = NULL;

  return NULL;
}

Err free_resetablegeneralfwdvols(double *wn1n2, double **paramatrix) {

  if (wn1n2)
    free_dvector(wn1n2, 1, 3);
  wn1n2 = NULL;

  if (paramatrix)
    free_dmatrix(paramatrix, 1, 2, 1, 5);
  paramatrix = NULL;

  return NULL;
}

/* Function which calculates the value of a Fra */

Err get_fra(long Fradate, int spotlag, char *cRefRateCode,
            char *szYieldCurveName, double *dFra);

/* Function which calibrates the parameters of the jump model to a caplet smile
corresponding to a specific matirity date */

Err calibtosmilefwdvols(long today, long dDate, char *cMarketId,
                        char *szVolCurveName, char *cRefRateCode,
                        char *szYieldCurveName, double *param, long *ia) {
  Err err = NULL;
  int i;
  int spotlag;
  double atmvol;
  double lognorm = 1.0;
  long dDatespot, dDatespot3;
  double Strikeinf, Strikesup;
  double mat;
  double dFra;
  double Strikespread;
  double *strikes;
  double *vols;
  double *calibvols;
  double s;
  int num_of_months;
  double chisq;
  SrtCrvPtr yldcrv;
  SrtBasisCode float_basis;
  SrtCompounding float_compounding;

  yldcrv = lookup_curve(szYieldCurveName);
  spotlag = get_spotlag_from_curve(yldcrv);

  /*Memory Allocation*/

  strikes = dvector(1, NMAXSTRIKES + 1);
  vols = dvector(1, NMAXSTRIKES + 1);
  calibvols = dvector(1, NMAXSTRIKES + 1);

  /* get info from the RefRate Code*/
  if (err = swp_f_get_ref_rate_details(cRefRateCode, &float_basis,
                                       &float_compounding)) {
    smessage("Error if swp_f_get_ref_rate_details");
  }

  num_of_months = 12 / float_compounding;

  /* We now get the strikes and the vols of the smile we will calibrate on*/

  err = get_fra(dDate, spotlag, cRefRateCode, szYieldCurveName, &dFra);

  dDatespot = add_unit(dDate, spotlag, SRT_BDAY, MODIFIED_SUCCEEDING);

  dDatespot3 =
      add_unit(dDatespot, num_of_months, SRT_MONTH, MODIFIED_SUCCEEDING);

  if (err = swp_f_vol(szVolCurveName, (double)dDatespot, (double)dDatespot3,
                      dFra, &atmvol, &lognorm)) {
    smessage("Error in swp_f_vol");
  }

  mat = (dDate - today) / 365.0;

  Strikeinf = dFra - 2 * atmvol * dFra * sqrt(mat);
  Strikesup = dFra + 2 * atmvol * dFra * sqrt(mat);
  Strikespread = (Strikesup - Strikeinf) / NMAXSTRIKES;

  s = Strikeinf;
  i = 1;

  while (s <= Strikesup) {
    strikes[i] = s;

    if (err = swp_f_vol(szVolCurveName, (double)dDatespot, (double)dDatespot3,
                        s, &(vols[i]), &lognorm)) {
      smessage("Error in swp_f_vol");
    }

    i++;
    s = s + Strikespread;
  }

  /* call the function which calibrates the Merton model to a given smile */
  err = optcalibmerton(dFra, NMAXSTRIKES, strikes, vols, param, mat,
                       "Lognormal", &chisq, ia, calibvols);

  /*free memory*/

  free_dvector(strikes, 1, NMAXSTRIKES + 1);
  free_dvector(vols, 1, NMAXSTRIKES + 1);
  free_dvector(calibvols, 1, NMAXSTRIKES + 1);

  return err;
}

/* General calibration function which calibrates the parameters to the smiles of
the resetdates of the resetable as well as the smile of the end date of the
product (going from the longer maturity to the shorter one)*/

Err resetablecalibfwdvols(long today, int n_resetdates, double *resetdates,
                          char *cMarketId, char *szVolCurveName,
                          char *cRefRateCode, char *szYieldCurveName,
                          double *paraminitguess, double **paramatrix)

{
  Err err = NULL;
  int i, j;
  long *freeze;

  /*memory allocation*/
  freeze = lngvector(1, 5);

  for (i = 1; i <= 5; i++) {
    freeze[i] = 1;
    paramatrix[n_resetdates][i] = paraminitguess[i];
  }

  /* First we calibrate the parameters to the caplet smile whose maturity
  corresponds to the end date of the resetable*/

  err = calibtosmilefwdvols(today, (long)resetdates[n_resetdates], cMarketId,
                            szVolCurveName, cRefRateCode, szYieldCurveName,
                            paramatrix[n_resetdates], freeze);

  /*freeze the amplitudes of the jumps*/
  freeze[2] = 0;
  freeze[4] = 0;

  /* now calibrates to the other smiles */

  for (j = n_resetdates - 1; j >= 1; j--) {

    for (i = 1; i <= 5; i++) {
      paramatrix[j][i] = paramatrix[j + 1][i];
    }

    err = calibtosmilefwdvols(today, (long)resetdates[j], cMarketId,
                              szVolCurveName, cRefRateCode, szYieldCurveName,
                              paramatrix[j], freeze);
  }

  /* free memory */

  free_lngvector(freeze, 1, 5);

  return err;
}

Err resetablecalibfwdvols_timedep(long today, int n_resetdates,
                                  double *resetdates, char *cMarketId,
                                  char *szVolCurveName, char *cRefRateCode,
                                  char *szYieldCurveName,
                                  double *paraminitguess, double **paramatrix)

{
  Err err = NULL;
  int i, j;
  long *freeze;
  double **parameters;

  /*memory allocation*/
  freeze = lngvector(1, 5 * n_resetdates);
  parameters = dmatrix(1, n_resetdates, 1, 5 * n_resetdates);

  for (i = 1; i <= 5 * n_resetdates; i++) {
    freeze[i] = 1;
  }

  for (i = 1; i <= 5; i++) {
    parameters[1][i] = paraminitguess[i];
  }

  /* First we calibrate the parameters to the caplet smile whose maturity
  corresponds to the end date of the resetable to get the "best" intensities*/

  err = calibtosmilefwdvols(today, (long)resetdates[n_resetdates], cMarketId,
                            szVolCurveName, cRefRateCode, szYieldCurveName,
                            parameters[1], freeze);

  /*freeze the amplitudes of the jumps*/
  freeze[3] = 0;
  freeze[5] = 0;

  /* now we calibrate everything */

  for (j = 2; j <= n_resetdates; j++) {

    for (i = 5 * (j - 1) + 1; i <= 5 * j; i++) {
      parameters[j][i] = paramatrix[j + 1][i];
    }

    err = calibtosmilefwdvols(today, (long)resetdates[j], cMarketId,
                              szVolCurveName, cRefRateCode, szYieldCurveName,
                              paramatrix[j], freeze);
  }

  /* free memory */

  free_lngvector(freeze, 1, 5);

  return err;
}

/* function which linearly interpolates the parameters obtained from the smiles
of the beginning and end of the period         , for a maturity in between*/

Err get_paramfwdvols(double Fradate, double *dates, double **paramatrix,
                     double *paramfra) {
  Err err = NULL;
  double datespread;

  /*linear interpolation of the parameters*/

  datespread = (dates[3] - dates[1]);

  paramfra[1] = (paramatrix[2][1] - paramatrix[1][1]) * (Fradate - dates[1]) /
                    datespread +
                paramatrix[1][1];

  paramfra[2] = paramatrix[1][2];

  paramfra[3] = (paramatrix[2][3] - paramatrix[1][3]) * (Fradate - dates[1]) /
                    datespread +
                paramatrix[1][3];

  paramfra[4] = paramatrix[1][4];

  paramfra[5] = (paramatrix[2][5] - paramatrix[1][5]) * (Fradate - dates[1]) /
                    datespread +
                paramatrix[1][5];

  return err;
}

Err get_param_fra_before_resetfwdvols(double Fradate, double *dates,
                                      double **paramatrix, double *paramfra) {
  Err err = NULL;
  double datespread;

  /*linear interpolation of the parameters*/

  datespread = (dates[3] - dates[1]);

  paramfra[1] = (paramatrix[2][1] - paramatrix[1][1]) * (Fradate - dates[1]) /
                    datespread +
                paramatrix[1][1];

  paramfra[2] = paramatrix[1][2];

  paramfra[3] = paramatrix[1][3];

  paramfra[4] = paramatrix[1][4];

  paramfra[5] = paramatrix[1][5];

  return err;
}

Err get_param_fra_after_resetfwdvols(double Fradate, double today, double fra,
                                     double frafwd, double cvg, double *dates,
                                     double **paramatrix, double *paramfra) {
  Err err = NULL;
  double datespread;

  /*linear interpolation of the parameters*/

  datespread = (dates[3] - dates[1]);

  paramfra[1] = (paramatrix[2][1] - paramatrix[1][1]) * (Fradate - dates[1]) /
                    datespread +
                paramatrix[1][1];

  paramfra[2] = paramatrix[1][2];

  paramfra[3] = ((dates[3] - today) * paramatrix[2][3] / datespread -
                 (dates[1] - today) *
                     (paramatrix[1][3] /
                      (1 + paramfra[2] * cvg * fra / (1 + cvg * fra))) /
                     datespread) *
                (1 + paramfra[2] * cvg * frafwd / (1 + cvg * frafwd));

  paramfra[4] = paramatrix[1][4];

  paramfra[5] = ((dates[3] - today) * paramatrix[2][5] / datespread -
                 (dates[1] - today) *
                     (paramatrix[1][5] /
                      (1 + paramfra[4] * cvg * fra / (1 + cvg * fra))) /
                     datespread) *
                (1 + paramfra[4] * cvg * frafwd / (1 + cvg * frafwd));

  return err;
}

/* Gets the DRS value for each fixing day within a period */

Err get_DRStsfwdvols(long today, long Paydate, double *mat, char *cRefRateCode,
                     char *szYieldCurveName, char *szVolCurveName,
                     Err (*GetVol)(double dStart, double dEnd, double dStrike,
                                   SRT_Boolean bAdjForSpread, double dForward,
                                   double dSpread, double *pdBsVol),
                     elemforCms passCms, char *UseDRS, double *DRSts) {
  Err err = NULL;
  int index;
  long FraSpot;
  double num_of_months, numperiods;
  double maturity;
  double delay;
  double enddate, theoenddate;
  int spotlag;
  double dFra;
  double dspread;
  SrtBasisCode float_basis;
  SrtCompounding float_compounding;
  SrtCrvPtr yldcrv;

  yldcrv = lookup_curve(szYieldCurveName);
  spotlag = get_spotlag_from_curve(yldcrv);

  for (index = 1; index <= 3; index++) {

    /* start date of the Fra*/
    FraSpot =
        add_unit((long)mat[index], spotlag, SRT_BDAY, MODIFIED_SUCCEEDING);

    /*Get details for the index Fra*/
    if (err = swp_f_get_ref_rate_details(cRefRateCode, &float_basis,
                                         &float_compounding)) {
      smessage("Error in swp_f_get_ref_rate_details");
    }

    num_of_months = 12 / float_compounding;

    maturity = coverage(today, (long)mat[index], BASIS_ACT_365);

    enddate =
        add_unit(FraSpot, (int)num_of_months, SRT_MONTH, MODIFIED_SUCCEEDING);

    theoenddate =
        add_unit(FraSpot, (int)num_of_months, SRT_MONTH, NO_BUSDAY_CONVENTION);

    numperiods = (theoenddate - FraSpot) * float_compounding / 365.0;

    /* computes the delay        , for use in the CMS rate computation*/
    delay = coverage(FraSpot, Paydate, BASIS_ACT_365);

    /* compute the fra */

    err = get_fra((long)mat[index], spotlag, cRefRateCode, szYieldCurveName,
                  &dFra);

    if (strcmp(UseDRS, "NO") == 0)

    {
      DRSts[index] = dFra;
    }

    else {
      /* computes the spread        , for use in the CMS rate computation*/
      dspread = swp_f_spread(FraSpot, enddate, cRefRateCode);

      /* Computes the CMS rate */

      if (err = swp_f_Cms_Rate(
              dFra, maturity, numperiods, (double)float_compounding, delay,
              365.0 / 360.0, SRT_LOGNORMAL, 0.0, 1 /*Full Smile Approx*/,
              FraSpot, (long)theoenddate, passCms.AdjForSpread,
              passCms.AdjForSpread * dspread, szVolCurveName,
              passCms.NumStrikesInVol, passCms.Strikes, &(DRSts[index]))) {
        smessage("Error in swp_f_Cms_Rate");
      }
    }
  }

  return err;
}

/* Using the Merton diffusion with fixed parameters        , computes the value
of a DRs corresponding to the solution of the SDE it satisfies*/

Err DRSCalcfwdvols(double *wn1n2, double resetmat, double **periodparam,
                   double *drift, double *DRSts) {

  Err err = NULL;

  int j;
  double T;
  double *paramfra;
  double sig, U1, U2, l1, l2;

  /*memory allocation*/
  paramfra = dvector(1, 5);

  for (j = 1; j <= 3; j++) {

    T = resetmat;

    sig = periodparam[j][1];
    U1 = periodparam[j][2];
    l1 = periodparam[j][3];
    U2 = periodparam[j][4];
    l2 = periodparam[j][5];

    DRSts[j] = DRSts[j] * exp(-sig * sig * T / 2 + sig * wn1n2[1] * sqrt(T)) *
               exp(wn1n2[2] * log(1 + U1) - l1 * U1 * T) *
               exp(wn1n2[3] * log(1 + U2) - l2 * U2 * T) * exp(drift[j] * T);
  }

  /*free memory*/
  free_dvector(paramfra, 1, 5);

  return err;
}

/* Main function*/

Err srt_f_mertonfwdvols(int seedo, double smiledate, int n_resetdates,
                        double *resetdates, int n_strikes, double *strikes,
                        double *initparam, char *UseDRS, char *cRefRateCode,
                        char *cMarketId, char *szYieldCurveName,
                        char *szVolCurveName,
                        Err (*GetVol)(double dStart, double dEnd,
                                      double dStrike, SRT_Boolean bAdjForSpread,
                                      double dForward, double dSpread,
                                      double *pdBsVol),
                        elemforCms passCms, double *res) {

  Err err = NULL;
  int j;
  double **paramatrix;
  double *DRSts, *DRStsStart;
  double **paramperiod;
  double *wn1n2;
  double resetmat;
  double drift;
  double *drift_before_reset;
  double *drift_after_reset;
  double cvg;
  double dFradrift, dFraFwddrift;
  int spotlag;
  double *dates;
  double *impvols;
  double jumps1, jumps2;
  /* double *discfact;*/
  long today;
  long idum;

  SrtBasisCode float_basis;
  SrtCompounding float_compounding;
  SrtCrvPtr yldcrv;

  yldcrv = lookup_curve(szYieldCurveName);
  today = get_today_from_curve(yldcrv);
  spotlag = get_spotlag_from_curve(yldcrv);
  /*uniform*/
  idum = -seedo;
  uniform(&idum);

  /*Get details for the index Fra*/
  if (err = swp_f_get_ref_rate_details(cRefRateCode, &float_basis,
                                       &float_compounding)) {
    smessage("Error in swp_f_get_ref_rate_details");
  }

  /*memory allocation*/
  paramatrix = dmatrix(1, 2, 1, 5);
  wn1n2 = dvector(1, 3);
  dates = dvector(1, 3);

  /*fill in the dates*/

  dates[1] = resetdates[1];
  dates[2] = smiledate;
  dates[3] = resetdates[2];

  /*disfact = dvector(1        ,n_resetdates-1);*/

  /* calibrate the parameters to the caplets smiles of the resetdates and end
   * date */

  err = resetablecalibfwdvols(today, n_resetdates, resetdates, cMarketId,
                              szVolCurveName, cRefRateCode, szYieldCurveName,
                              initparam, paramatrix);
  if (err) {
    free_resetablegeneralfwdvols(wn1n2, paramatrix);
    return err;
  }

  /*memory allocation*/
  DRStsStart = dvector(1, 3);
  paramperiod = dmatrix(1, 3, 1, 5);
  DRSts = dvector(1, 3);
  drift_before_reset = dvector(1, 3);
  drift_after_reset = dvector(1, 3);
  impvols = dvector(1, n_strikes);

  err = get_DRStsfwdvols(today, (long)dates[3], dates, cRefRateCode,
                         szYieldCurveName, szVolCurveName, GetVol, passCms,
                         UseDRS, DRStsStart);
  if (err) {
    free_resetableperiodfwdvols(paramperiod, dates, DRStsStart, DRSts,
                                drift_before_reset, drift_after_reset);
    free_resetablegeneralfwdvols(wn1n2, paramatrix);
    return err;
  }

  cvg = coverage((long)dates[3],
                 add_unit((long)dates[3], (int)(12 / float_compounding),
                          SRT_MONTH, MODIFIED_SUCCEEDING),
                 float_basis);
  /* here        , we get the parameters corresponding to each fixing day within
   the period and put them in paramperiod which is a matrix with nfixdays rows
   and 5 columns (for the 5 parameters)*/

  if (strcmp(UseDRS, "YES") == 0) {

    for (j = 1; j <= 3; j++) {
      err = get_paramfwdvols(dates[j], dates, paramatrix, paramperiod[j]);

      drift_before_reset[j] = 0;

      if (err) {

        free_resetableperiodfwdvols(paramperiod, dates, DRStsStart, DRSts,
                                    drift_before_reset, drift_after_reset);
        free_resetablegeneralfwdvols(wn1n2, paramatrix);
        return err;
      }
    }
  }

  else {
    err = get_fra((long)resetdates[2], spotlag, cRefRateCode, szYieldCurveName,
                  &dFradrift);

    drift =
        paramatrix[1][1] * cvg * dFradrift / (1 + cvg * dFradrift) +
        paramatrix[1][3] + paramatrix[1][5] -
        paramatrix[1][3] /
            (1 + paramatrix[1][2] * cvg * dFradrift / (1 + cvg * dFradrift)) -
        paramatrix[1][5] /
            (1 + paramatrix[1][4] * cvg * dFradrift / (1 + cvg * dFradrift));

    for (j = 1; j <= 3; j++) {
      err = get_param_fra_before_resetfwdvols(dates[j], dates, paramatrix,
                                              paramperiod[j]);

      drift_before_reset[j] =
          drift * (dates[j] - dates[1]) / (dates[3] - dates[1]);

      if (err) {

        free_resetableperiodfwdvols(paramperiod, dates, DRStsStart, DRSts,
                                    drift_before_reset, drift_after_reset);
        free_resetablegeneralfwdvols(wn1n2, paramatrix);
        return err;
      }
    }
  }

  resetmat = (dates[1] - today) / 365.0;

  /* maximum values for the number of positive and negative jumps are computed
  for the resetdate (start date) of the period in question */

  for (j = 1; j <= 3; j++) {
    DRSts[j] = DRStsStart[j];
  }
  /*get the simulated Brownian and Poissons*/
  wn1n2[1] = inv_cumnorm_fast(uniform(&idum));
  wn1n2[2] = 0;
  wn1n2[3] = 0;
  jumps1 = -log(uniform(&idum)) / paramperiod[1][3];
  jumps2 = -log(uniform(&idum)) / paramperiod[1][5];

  while (jumps1 < resetmat) {
    jumps1 += -log(uniform(&idum)) / paramperiod[1][3];
    wn1n2[2]++;
  }

  while (jumps2 < resetmat) {
    jumps2 += -log(uniform(&idum)) / paramperiod[1][5];
    wn1n2[3]++;
  }

  err = DRSCalcfwdvols(wn1n2, resetmat, paramperiod, drift_before_reset, DRSts);

  if (err) {
    free_resetableperiodfwdvols(paramperiod, dates, DRStsStart, DRSts,
                                drift_before_reset, drift_after_reset);
    free_resetablegeneralfwdvols(wn1n2, paramatrix);
    return err;
  }

  if (strcmp(UseDRS, "YES") != 0)

  {

    dFraFwddrift = DRSts[3];

    for (j = 1; j <= 3; j++) {
      err = get_param_fra_after_resetfwdvols(dates[j], today, dFradrift,
                                             dFraFwddrift, cvg, dates,
                                             paramatrix, paramperiod[j]);

      drift_after_reset[j] =
          paramperiod[j][3] *
          (1 - 1 / (1 + paramperiod[j][2] * cvg * dFraFwddrift /
                            (1 + cvg * dFraFwddrift)));
      drift_after_reset[j] +=
          paramperiod[j][5] *
          (1 - 1 / (1 + paramperiod[j][4] * cvg * dFraFwddrift /
                            (1 + cvg * dFraFwddrift)));
      drift_after_reset[j] *= (dates[j] - dates[1]) / (dates[3] - dates[1]);

      DRSts[j] *= exp(drift_after_reset[j] * (dates[1] - today) / 365.0);

      if (err) {
        free_resetableperiodfwdvols(paramperiod, dates, DRStsStart, DRSts,
                                    drift_before_reset, drift_after_reset);
        free_resetablegeneralfwdvols(wn1n2, paramatrix);
        return err;
      }
    }
  }

  optmertonsmile(DRSts[2], n_strikes, strikes, paramperiod[2],
                 (dates[2] - dates[1]) / 365.0, "Lognormal", impvols);

  res[1] = DRSts[1] / DRStsStart[1];
  res[2] = DRSts[2] / DRStsStart[2];
  res[3] = DRSts[3] / DRStsStart[3];

  for (j = 1; j <= n_strikes; j++) {
    res[j + 3] = impvols[j];
  }

  free_resetableperiodfwdvols(paramperiod, dates, DRStsStart, DRSts,
                              drift_before_reset, drift_after_reset);
  free_resetablegeneralfwdvols(wn1n2, paramatrix);
  free_dvector(impvols, 1, n_strikes);

  return err;
}
