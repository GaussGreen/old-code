/////////////////////////////////////////////////////////////////////////////
// Name:        ito33/win32/seh.h
// Purpose:     helpers for dealing with Win32 structured exceptions
// Author:      Vadim Zeitlin
// Created:     01.04.04
// RCS-ID:      $Id: seh.h,v 1.3 2004/10/05 09:13:40 pedro Exp $
// Copyright:   (c) 2004 Trilemma LLP
/////////////////////////////////////////////////////////////////////////////

/**
    @file ito33/win32/seh.h
    @brief Helper for dealing with Win32 structured exceptions (SE).

    Under Win32 there are two sorts of exceptions: the normal C++ ones and the
    ``structured exceptions'' generated by the OS itself for program faults
    (access violation, stack overflow, division by zero, ...). Normally the C++
    exceptions are caught with try/catch and the SE -- with (non standard)
    __try/__except blocks. This is not very convenient because two forms of the
    exception handling can't be both used in the same function, but it would
    have been ok.

    Unfortunately, in their infinite wisdom Microsoft programmers have decided
    to implicitly translate Win32 SE into "something" which is caught by C++
    "catch ( ... )" clause. This "something" doesn't have any C++ type and so
    can't be caught by any other means nor can we do anything with it,
    including obtaining the EXCEPTION_POINTERS structure containing the
    information about the exception and invaluable for the crash report
    generation (see CrashReport) and which is available to __except.

    The only way out of this mess is either to never use "catch ( ... )" or to
    do what we do. Before describing what it is, please notice that never using
    such catch would be in general a good idea but we unfortunately simply must
    do it in our COM code because a COM DLL is not supposed to bring down the
    entire application hosting it, i.e. an error in our code should not crash
    Excel in which we're embedded and using "catch ( ... )" is the most fool
    proof way to achieve this.

    So we choose to use VC++-specific feature which allows to translate SE into
    C++ ones. This would make it possible to catch them normally but as we only
    want to generate the crash reports we simply do it inside the translator
    function itself as it has access to all the required information.
 */

#ifndef _ITO33_WIN32_SEH_H_
#define _ITO33_WIN32_SEH_H_

struct _EXCEPTION_POINTERS;

namespace ito33
{

namespace Win32
{

/**
    Set up the SEH.

    This function should be called on program startup or on DLL load, as early
    as possible.
 */
void InitializeSEH();

/**
    SE to C++ exceptions translator.

    In our case, the translator throws an object of type StructuredException
    and also uses CrashReporr to generate the crash report for this exception.

    @param code result of Win32 GetExceptionCode() function
    @param pEP result of Win32 GetExceptionInformation() function
 */
extern void SEtranslator(unsigned int code, _EXCEPTION_POINTERS *pEP);

/**
    C++ exception class corresponding to the Win32 structued exceptions.

    An object of this type is thrown when a program fault occurs, the only
    handling for this kind of exception is to generate a crash report (done
    automatically by our SEtranslator() function) and terminate.

    Note that this class intentionally does @b not derive from ito33::Exception
    as we never throw such objects ourselves and we don't want to accidentally
    catch them with the other exceptions because this one represents a program
    bug, unlike the other ones, and should always be treated separately.
 */
class StructuredException
{
public:
  // ctor is private below; default copy ctor, dtor and operator=() are ok

  /// Return the Win32 exception code.
  unsigned int GetCode() const { return m_nCode; }

private:
  /**
      Ctor.

      As these exceptions are only created by SEtranslator, it is private.
   */
  StructuredException(unsigned int nCode)
  {
    m_nCode = nCode;
  }

  unsigned int m_nCode;

  friend void SEtranslator(unsigned int, _EXCEPTION_POINTERS *);
};

} // namespace Win32

} // namespace ito33

#endif // _ITO33_WIN32_SEH_H_

