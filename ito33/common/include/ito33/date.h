/////////////////////////////////////////////////////////////////////////////
// Name:        ito33/date.h
// Purpose:     Date class
// Author:      Vadim Zeitlin
// Created:     16.12.02
// RCS-ID:      $Id: date.h,v 1.40 2006/08/02 13:29:02 cosmin Exp $
// Copyright:   (c) 2002 Trilemma LLP
/////////////////////////////////////////////////////////////////////////////

/**
    @file ito33/date.h
    @brief Classes for working with dates.

    The Date class represents an absolute date. It uses only integer
    arithmetics and so doesn't suffer from the floating point rounding
    errors -- but still provides a respectable range of supported days (from
    Nov 24, -4713 to Jun 5, 2934905) on machines with 32 bit longs.

    Date supports arithmetic operations using several usual financial
    conventions and also provides methods to convert dates to and from strings.
 */

#ifndef _ITO33_DATE_H_
#define _ITO33_DATE_H_

#include "ito33/common.h"

#include "ito33/beforestd.h"
#include <iostream>
#include "ito33/afterstd.h"

#include <limits.h>         // for ULONG_MAX

#include "ito33/string.h"
#include "ito33/exception.h"
#include "ito33/debug.h"

struct tm;


namespace ito33
{

/**
    Date represents an absolute date.

    This class is meant to be small and efficient, its sizeof() is equal to
    just 4 bytes usually and, in particular, it doesn't have virtual dtor and so
    shouldn't be used polymorphically.
*/
class ITO33_DLLDECL Date
{
public:
  /// @name constants and types
  //@{

  /// symbolic month names
  enum Month
  {
    // Inv_Month is first, not last as usual as we want Jan == 1 anyhow
    Inv_Month,

    Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec,

    MONTHS_IN_YEAR = Dec
  };

  /// symbolic names for the weekdays
  enum WeekDay
  {
    // but we have Sun == 0 (note that if this is changed, GetDayOfWeek()
    // will have to be modified!)
    Inv_WeekDay = -1,

    Sun, Mon, Tue, Wed, Thu, Fri, Sat,

    DAYS_PER_WEEK
  };

  /// flags for GetWeekOfYear and GetWeekOfMonth
  enum WeekFlags
  {
    Default_First,   // Sunday_First for US, Monday_First for the rest
    Monday_First,    // week starts with a Monday
    Sunday_First     // week starts with a Sunday
  };

  /// signed integer type which can hold the year values
  typedef long Year_t;

  /// an unsigned integer type for the day values (1..366 at least)
  typedef unsigned int Day_t;

  /** 
    Convention used for counting number of days between two dates or
    counting year fractions.
   */
  /*  
    IMPORTANT: The order is important and then, if a DCC should be added, 
               it must be added either just before the first DCC with NO EOM 
               (if it is not a NO EOM one), or at the end of the NO EOM list
               of DCC with NO EOM. Indeed, in the implementation of some
               functions (e.g. GenerateRegularPeriodsFrom(..)), we compare
               the value of the day count convention to the first NO_EOM 
               day count convention (which is here 
               DayCountConvention_30360_NO_EOM) to know if the day count
               is an EOM one or a NO_EOM one.
  */
  enum DayCountConvention
  {
    DayCountConvention_30360,
    DayCountConvention_30E360,
    DayCountConvention_30U360,
    DayCountConvention_ActAct, // ISMA interpretation
    //DayCountConvention_ActAct_ISDA,
    DayCountConvention_Act360,
    DayCountConvention_Act365,
    DayCountConvention_Act365L,
    // Day count conventions with NO EOM (Non End Of Month)
    DayCountConvention_30360_NO_EOM,
    DayCountConvention_30E360_NO_EOM,
    DayCountConvention_30U360_NO_EOM,
    DayCountConvention_ActAct_NO_EOM,
    //DayCountConvention_ActAct_ISDA_NO_EOM,
    DayCountConvention_Act360_NO_EOM,
    DayCountConvention_Act365_NO_EOM,
    DayCountConvention_Act365L_NO_EOM,
    DayCountConvention_Max,

    // more verbose synonim (also needed for backwards compatibility)
    DayCountConvention_30360european = DayCountConvention_30E360
  };

  //@}

#ifndef __CPP2ANY__
  /**
      Exception: all exceptions generated by Date itself (as opposed to the
      ones simply propagating upwards through Date ) are of this class.

      The Date class may throw only the exceptions of this class.
   */
  class Exception : public ito33::Exception
  {
  public:
    /**
        Ctor for the Exception object.

        Use the standard EXCEPTION macro to create Exception objects, this
        frees you from having to type __FILE__, __LINE__ and __FUNCTION__
     */
    Exception(int errorCode,
         const char *message,
         const char *filename,
         size_t line,
         const char *function)
      : ito33::Exception(errorCode, message, filename, line, function)
      {
      }
  };
#endif // __CPP2ANY__


  /// @name constructors and dtor
  //@{

  // default ctor initializes the object to invalid date, i.e. IsValid() for
  // the object will return false
  Date();

  // default copy ctor (and assignment operators) are ok
  // Date(const Date& date);

  /**
     ctor from the given calendar date: year must include the century,
     month is an enum element from above (in particular, 1 is Feb, Jan is 0)
     and day is counted from 1, as usual

     this ctor will throw if the date specified is invalid
   */
  Date(Year_t year, Month month, Day_t day);

  /**
     ctor from a string representation using the given format (the same
     format specifiers as in strftime(3) are supported), default format is
     the one corresponding to the current locale

     this ctor will throw an exception if the string can't be parsed
   */
  Date(const char *date, const char *format = "%x");

  /**
      Constructs a Date object from an Excel date.

      This ctor is dangerous because it means that all built-in numeral types
      may be implicitly converted to dates, but it is simply too convenient
      when we work with the Excel dates to do without it.
   */
  Date(unsigned long serial);

  // dtor is not virtual in sake of the space efficiency, this class should
  // not be used polymorphically
  // ~Date(); -- default dtor is ok

  //@}


  /// @name initializers/setters and assignment operators
  //@{

  /// reset the date, making it invalid
  void Clear();

  /// assign another date, returns this object
  Date& Set(const Date& date);

  /**
     assign the given calendar date using the same conventions as the
     corresponding ctor

     this method will throw if the date is invalid
   */
  Date& Set(Year_t year, Month month, Day_t day);

  /**
     assign the date specified by the given string and format, see the
     corresponding ctor for more

     this method will throw if the date is invalid
   */
  Date& Set(const char *date, const char *format = "%x");

  /**
     set the date to the given Julian Day Number which are defined here as
     chronological (as opposed to astronomical), ie JDN 0 is the midnight
     of Jan 1, 4713 BC in the proleptic Julian calendar

     this method will throw if the JDN is out of range
   */
  Date& SetJDN(unsigned long jdn);

  /**
     set the date to the Excel date

     this method will throw if the date is out of range
   */
  Date& SetExcel(unsigned long serial);

  /**
     set the date to the midnight preceding the given moment of time.
   */
  Date& SetTicks(time_t t);

  /**
     set the date to the midnight preceding the given moment of time.
   */
  Date& SetTM(const struct tm& tm);

  /**
     set to the given year day in the specified year

     this method will throw if the date is out of range
   */
  Date& SetYearDay(Year_t year, Day_t day);

  //@}


  /**
      @name factory functions
   */
  //@{

  /// creates a date corresponding to the given time in ticks
  static Date FromTicks(time_t t)
  {
    Date d;
    d.SetTicks(t);
    return d;
  }

  /// creates a date corresponding to the given broken down time
  static Date FromTM(const struct tm& tm)
  {
    Date d;
    d.SetTM(tm);
    return d;
  }

  /// creates a date corresponding to the given Excel serial number
  static Date FromExcel(double serial)
  {
    // discard the time part of the date
    return Date(static_cast<unsigned long>(serial));
  }

  //@}


  /**
      @name accessors

      NB: all methods in this section except IsValid() throw an exception if
          the object is not initialized
   */
  //@{

  /// return true if the object has been initialized
  bool IsValid() const;

  /// returns the JDN of this date
  unsigned long GetJDN() const;

  /// returns the Excel serial value of this date
  unsigned long GetExcel() const;

  /// get the time_t value corresponding to the midnight of the given date
  time_t GetTicks() const;

  /// returns the year
  Year_t GetYear() const;

  /// returns the month
  Month GetMonth() const;

  /// returns the day in the month, in range [1..31]
  Day_t GetDay() const;

  /// returns the week day
  WeekDay GetDayOfWeek() const;

  /// returns the day in the year, in range [1..366]
  Day_t GetDayOfYear() const;

  /**
     get the week number since the year start (in the range 0..53, week 1 is
     always the first week according to ISO 8601, ie contains Jan 4, week 0
     corresponds to the last ISO week of the previous year)
   */
  Day_t GetWeekOfYear(WeekFlags flags = Monday_First) const;

  //@}


  /// @name calendar information
  //@{

  /// is the given year a leap one?
  static bool IsLeapYear(Year_t year);

  /// is this date in a leap year?
  bool IsLeap() const;

  /// return the number of days (28..31) in the given month/year
  static Day_t GetNumOfDaysInMonth(Year_t year, Month month);

  /// return the number of days (365 or 366) in the given year
  static Day_t GetNumOfDaysInYear(Year_t year);

  /// return the today date (in the local time zone)
  static Date Today();

  //@}


  /// @name conversions to/from strings
  //@{

  /**
     same as Set(const char *date) but doesn't throw an exception if the
     string couldn't be parsed

     returns the character which stopped the scan (i.e. the one which doesn't
     belong to the date we parsed any more) on success or NULL on failure
   */
  const char *Parse(const char *date, const char *format = "%x");

  /// returns the string representation of the date, similar to strftime(3)
  std::string Format(const char *format = "%x") const;

  //@}


  /// @name conversions to/from other date formats
  //@{

#ifdef _WIN32
  /// convert to OLE DATE format
  double GetOleDate() const;

  /// convert from OLE format
  Date& SetOleDate(double d);
#endif // _WIN32

  //@}


  /**
      @name arithmetic operations

      NB: all methods in this section throw an exception if the object is not
          initialized
   */
  //@{

  /// adds the given number of days, positive or negative
  Date& AddDays(int days);

  /**
     adds the given number of months, positive or negative (note that the day
     may be changed as well by this function if it's > 28)
   */
  Date& AddMonths(int months);

  /**
     returns the last day of the month which is months from this date, ie
     EndOfMonth(0) returns the last day of this month and EndOfMonth(+1/-1)
     returns the last day of the next/previous month
   */
  Date& EndOfMonth(int months);

  /**
     adds the given (entire) number of years, ie equivalent to
     AddMonths(12*years)
   */
  Date& AddYears(int years);

  /**
     Returns the (real) number of days between two dates.

     Result is > 0 if date1 < date2.
     
     @param date1 First date
     @param date2 Second date

     @return The real numbers of days between two dates.
   */
  static long DaysDiff(const Date& date1, const Date& date2);

  /**
     Returns the number of days between two dates taking into account of the
             day count convention.

     Result is >= 0 if date1 <= date2.
     
     @param date1 First date.
     @param date2 Second date.
     @param dcc The day count convention used.

     @return The numbers of days between two dates taking into account of the
             day count convention.
   */
  static long DaysDiffWithDayCount(const Date& date1, const Date& date2,
                                   DayCountConvention dcc);

  /**
     Returns the fraction of years between two dates computed using the given
     convention.

     Result is >= 0 if date1 <= date2.
     
     @param date1 First date.
     @param date2 Second date.
     @param dcc The day count convention used.

     @return The fraction of years between two dates taking into account of the
             day count convention.
   */
  static double YearsDiff(const Date& date1,
                          const Date& date2,
                          DayCountConvention dcc);

  //@}


  /**
      @name operations on months and week days

      With to these functions we can write loops like this:

      <pre>
      for ( m = Date::Jan; m < Date::Inv_Month; Date::NextMonth(m) )
          ...
      </pre>
  */
  //@{

  /// returns the month following the given one or Inv_Month for Dec
  static void NextMonth(Month& m);

  /// returns the month before the given one or Inv_Month for Jan
  static void PrevMonth(Month& m);

  /// returns the week day following the given one or Inv_WeekDay for Sat
  static void NextWeekDay(WeekDay& m);

  /// returns the week day before the given one or Inv_WeekDay for Sun
  static void PrevWeekDay(WeekDay& m);

  //@}

#ifndef __CPP2ANY__
  /// @name Implementation details mostly.
  //@{
  /**
      struct mimicking the standard struct tm and representing a broken down
      Julian/Gregorian calendar date
   */
  struct Tm
  {
    Year_t year;
    Month mon;
    Day_t mday;
  };

  /// return the broken down representation of this object
  Tm GetTm() const;

  /// set the object to the given year, month, day
  Date& SetTm(const Tm& tm);

  //@}
#endif // __CPP2ANY__

private:
  // this function thorws exception when the date/date format is not valid
  static void ThrowBadDate();

  // this function checks that we're valid and generates an assert and throws
  // an exception if we're not
  void Check() const;


  // helper of AddMonths() and EndOfMonth(): adds months to the current date
  // and returns the resulting month and year (the mday field of the returned
  // struct is the same as the current day which means that the struct could
  // be invalid!)
  Tm DoAddMonths(int months) const;


  // the JDN corresponding to this date or ULONG_MAX if invalid
  unsigned long m_jdn;
};

/// function for printing out a Date
inline std::ostream& operator<<(std::ostream& ostr, const Date& date)
{
  // use ISO 8601
  ostr << date.Format("%Y-%m-%d");

  return ostr;
}

// ============================================================================
// inline functions implementation
// ============================================================================

// NB: the order of functions should be such that inlining could be really
//     done which means that if a function A uses function B, B should appear
//     before A

inline Date& Date::SetJDN(unsigned long jdn)
{
  m_jdn = jdn;

  return *this;
}

inline Date& Date::Set(const Date& date)
{
  return SetJDN(date.m_jdn);
}

inline Date& Date::Set(const char *date, const char *format)
{
  if ( !Parse(date, format) )
    ThrowBadDate();

  return *this;
}

inline void Date::Clear()
{
  SetJDN(ULONG_MAX);
}

inline Date::Date()
{
  Clear();
}

inline Date::Date(Date::Year_t year, Date::Month month, Date::Day_t day)
{
  Set(year, month, day);
}

inline Date::Date(const char *date, const char *format)
{
  Set(date, format);
}

inline Date::Date(unsigned long serial)
{
  SetExcel(serial);
}

inline bool Date::IsValid() const
{
  return m_jdn != ULONG_MAX;
}

inline unsigned long Date::GetJDN() const
{
  Check();

  return m_jdn;
}

inline Date::Year_t Date::GetYear() const
{
  return GetTm().year;
}

inline Date::Month Date::GetMonth() const
{
  return GetTm().mon;
}

inline Date::Day_t Date::GetDay() const
{
  return GetTm().mday;
}

inline Date::WeekDay Date::GetDayOfWeek() const
{
  // JDN 0 is Monday so simply taking % 7 we get a Monday-based weekday
  unsigned long wd = GetJDN() % DAYS_PER_WEEK;

  if ( wd == DAYS_PER_WEEK - 1 )
    return Sun;

  return (WeekDay)(wd + 1);
}

inline bool Date::IsLeapYear(Date::Year_t year)
{
  return (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));
}

inline bool Date::IsLeap() const
{
  return IsLeapYear(GetYear());
}

/* static */
inline Date::Day_t Date::GetNumOfDaysInYear(Year_t year)
{
  return (Day_t)(IsLeapYear(year) ? 366 : 365);
}

inline Date& Date::AddDays(int days)
{
  Check();

  m_jdn += days;

  return *this;
}

inline Date& Date::AddYears(int years)
{
  return AddMonths(12*years);
}

/* static */ inline long Date::DaysDiff(const Date& date1, const Date& date2)
{
  date1.Check();
  date2.Check();

  return date2.m_jdn - date1.m_jdn;
}

inline void Date::NextMonth(Date::Month& m)
{
  ASSERT_MSG( m < Date::Inv_Month, "invalid month" );

  // no wrapping or the for loop above would never end!
  m = (Date::Month)(m + 1);
}

inline void Date::PrevMonth(Date::Month& m)
{
  ASSERT_MSG( m < Date::Inv_Month, "invalid month" );

  m = m == Date::Jan ? Date::Inv_Month : (Date::Month)(m - 1);
}

inline void Date::NextWeekDay(Date::WeekDay& wd)
{
  ASSERT_MSG( wd < Date::Inv_WeekDay, "invalid week day" );

  // no wrapping or the for loop above would never end!
  wd = (Date::WeekDay)(wd + 1);
}

inline void Date::PrevWeekDay(Date::WeekDay& wd)
{
  ASSERT_MSG( wd < Date::Inv_WeekDay, "invalid week day" );

  wd = wd == Date::Sun ? Date::Inv_WeekDay : (Date::WeekDay)(wd - 1);
}

inline Date& Date::SetTm(const Tm& tm)
{
  return Set(tm.year, tm.mon, tm.mday);
}

// comparison operators
// ----------------------------------------------------------------------------

/*
    NB: any attempt to compare an invalid date object result in an exception
        being thrown even if the other date object is invalid as well.
 */

/// compares two dates for equality
inline bool operator==(const Date& date1, const Date& date2)
{
  return date1.GetJDN() == date2.GetJDN();
}

/// compares two dates for inequality
inline bool operator!=(const Date& date1, const Date& date2)
{
  return date1.GetJDN() != date2.GetJDN();
}

/// compares two dates
inline bool operator<(const Date& date1, const Date& date2)
{
  return date1.GetJDN() < date2.GetJDN();
}

/// compares two dates
inline bool operator<=(const Date& date1, const Date& date2)
{
  return date1.GetJDN() <= date2.GetJDN();
}

/// compares two dates
inline bool operator>(const Date& date1, const Date& date2)
{
  return date1.GetJDN() > date2.GetJDN();
}

/// compares two dates
inline bool operator>=(const Date& date1, const Date& date2)
{
  return date1.GetJDN() >= date2.GetJDN();
}

/// Check if the given day count convention is of EOM or NO_EOM
inline bool IsEOM(Date::DayCountConvention dcc)
{
  return dcc < Date::DayCountConvention_30360_NO_EOM;
}

/// Checks if given day count convention is valid.
inline bool IsValid(Date::DayCountConvention dcc)
{
  return dcc >= 0 && dcc < Date::DayCountConvention_Max;
}

// this function thorws exception when theday count convention is not valid
void ThrowBadDCC();

/// validation of DayCountConvention
inline void Validate(Date::DayCountConvention dcc)
{
  if ( !IsValid(dcc) )
    ThrowBadDCC();
}

} // namespace ito33

#endif // _ITO33_DATE_H_
