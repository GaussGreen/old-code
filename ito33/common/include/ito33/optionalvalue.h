/////////////////////////////////////////////////////////////////////////////
// Name:        ito33/optionalvalue.h
// Purpose:     template for handling optional values
// Author:      Pedro Ferreira
// Created:     2006-01-09
// RCS-ID:      $Id: optionalvalue.h,v 1.9 2006/06/05 11:19:25 zhang Exp $
// Copyright:   (c) 2004 Trilemma LLP
/////////////////////////////////////////////////////////////////////////////

/**
    @file ito33/optionalvalue.h
    @brief Template class for handling of optional values.

    This header defines a template class for handling optional values.
 */

#ifndef _ITO33_OPTIONALVALUE_H_
#define _ITO33_OPTIONALVALUE_H_

#include <stdexcept>
#include <sstream>
#include <string>

#include "ito33/meta/typetraits.h"

namespace ito33
{

/**
    This class represents a value of type T wich is optional on some
    context.

    For example, on opsession datastore it is used to replace the usage of pairs
    (field, has_field).
 */
template <typename T>
class OptionalValue
{
  public:
  /// a scalar type which doesn't risk to be converted to anything
  typedef void (OptionalValue<T>::*unspecified_bool_type)
          (typename ito33::meta::ArgType<T>::Value);

 /**
      Exception: all exceptions generated by OptionalValue
      are of this class.

      The OptionalValue class may throw only the exceptions of
      this class. Currently the only possible exception is
      access to value of invalid object.
   */
  class Exception : public std::runtime_error
  {
  public:
    /// Ctor for the Exception object.
    Exception(const char *filename,
              size_t line,
              const char *function)
      : std::runtime_error(""),
        m_message("Invalid access to optional value in ")
    {
      std::ostringstream tmessage;
      tmessage  << filename << ", line " << (unsigned int) line <<
                 ", function " << function;
      m_message += tmessage.str();
    }

    ~Exception() throw() {}

    /// Error message
    virtual const char *what() const throw()
    {
      return m_message.c_str();
    }

  private:
    std::string m_message;
  };

  /// Default constructor, value is invalid.
  OptionalValue() : m_isValid(false)
  {}

  /**
      Initializes the object with new value.
      The state is valid.

      @param value the value to initialize the object.
   */
  OptionalValue(typename ito33::meta::ArgType<T>::Value value)
    : m_isValid(true), m_value(value)
  {}

  // default constructor and destructor are OK for this class

  /// Invalidates the object.
  void Reset()
  {
    m_isValid = false;
  }

  /**
      Returns true if the object is valid.
   */
  bool IsValid() const { return m_isValid; }

  /// Returns a pointer to the stored value.
  T* operator->()
  {
    if ( !m_isValid )
      throw Exception(__FILE__, __LINE__, __FUNCTION__);

    return &m_value;
  }

  /// Returns a const pointer to the stored value.
  const T* operator->() const
  {
    if ( !m_isValid )
      throw Exception(__FILE__, __LINE__, __FUNCTION__);

    return &m_value;
  }

  /// Returns a reference to the stored value.
  T& operator*()
  {
    if ( !m_isValid )
      throw Exception(__FILE__, __LINE__, __FUNCTION__);

    return m_value;
  }

  /// Returns a const reference to the stored value.
  const T& operator*() const
  {
    if ( !m_isValid )
      throw Exception(__FILE__, __LINE__, __FUNCTION__);

    return m_value;
  }

  /**
      Tests the validity of the object.

      This allows tests like if (p) where p is
      an OptionalValue.
   */
  operator unspecified_bool_type() const
  {
    return m_isValid ? &OptionalValue<T>::Set : NULL ;
  }

  /**
      Sets the stored value.

      @param value the object to assign.
   */
  void Set(typename ito33::meta::ArgType<T>::Value value)
  {
    m_value = value;
    m_isValid = true;
  }

  /**
      Compares two optional values.

      Two optional values are equal if they have the same state and
      in the case they are valid if they share the same value.

      @param other the value to be compared.
   */
  bool operator==(const OptionalValue &other) const
  {
    if ( m_isValid != other.m_isValid )
      return false;
    if ( m_isValid )
      return m_value == other.m_value;
    return true;
  }

  /**
      Compares two optional values for inequality.

      @param other the value to be compared.
   */
  bool operator!=(const OptionalValue &other) const
  {
    return ! operator==(other);
  }

private:
  bool m_isValid;
  T m_value;
};

} // end namespace datastore

#endif // _ITO33_OPTIONALVALUE_H_
