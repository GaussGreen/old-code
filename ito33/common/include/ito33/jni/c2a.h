/////////////////////////////////////////////////////////////////////////////
// Name:        ito33/jni/c2a.h
// Purpose:     support file for C2A-generated code
// Author:      Vadim Zeitlin
// Created:     2004-07-30
// RCS-ID:      $Id: c2a.h,v 1.26 2006/08/19 22:19:48 wang Exp $
// Copyright:   (c) 2004 TT-Solutions
/////////////////////////////////////////////////////////////////////////////

/**
    @file ito33/jni/c2a.h
    @brief This file defines support functions used by C2A-generated code.

    All JNI files generated by cpp2any include this file, so the declarations
    here are available everywhere.
 */

#ifndef _ITO_JNI_C2A_H_
#define _ITO_JNI_C2A_H_

#include "ito33/beforestd.h"
#include <list>
#include <memory>
#include <string>
#include <vector>
#include "ito33/afterstd.h"

#include <time.h>

#include "ito33/array.h"
#include "ito33/exception.h"
#include "ito33/error.h"
#include "ito33/sharedptr.h"
#include "ito33/date.h"
#include "ito33/jni/jnixx.h"

using namespace ito33;

extern const ito33::Error ITO33_NULL_PARAM;

/**
    This namespace contains all the declarations used by the generaed code.
 */
namespace C2A
{

/**
    Java backend-specific stuff used by cpp2any-generated code.
 */
namespace Java
{

/**
    Traits type which allows us to get Java names of C++ classes.

    This template is specialized for different classes in cpp2any-generated
    code and provides a static GetFullName() function which returns the JNI
    spec of the class T.
 */
template <class T>
struct TypeInfo
{
    static const char *GetFullName();
};

template <class T>
struct TypeInfo< shared_ptr<T> >
{
  static const char *GetFullName() { return TypeInfo<T>::GetFullName(); }
};


/**
    This template maps C++ types and values to JNI ones and vice versa.

    The generic version translate between Java and C++ objects, there are
    specializations for other things below.
 */
template <typename T>
struct Translate
{
    typedef T CppType;
    typedef jobject JNIType;

    static T *From(JNI::Env& env, jobject obj)
    {
        if ( !obj )
            throw EXCEPTION_MSG(ITO33_NULL_PARAM, "Object is null.");

        JNI::FieldId<jlong> idSelf("m_self");
        const jlong ptr = env.GetLongField(obj, idSelf);

        // Java object keeps a shared pointer containing the real object
        return reinterpret_cast<shared_ptr<T> *>(ptr)->get();
    }

    static jobject To(JNI::Env& env, const T& obj)
    {
        typedef shared_ptr<T> ShPtr;

        return Translate< ShPtr >::To
               (
                  env,
                  ShPtr(new T(obj))
               );
    }

    /**
        Same as above but for pointers.

        Normally this shouldn't exist because cpp2any is supposed to transform
        pointers into references itself but due to a parser bug this doesn't
        happen now, so we need this kludge.
     */
    static jobject To(JNI::Env& env, const T *obj)
    {
        return To(env, *obj);
    }
};

/**
    Specialization for primitive types.

    Although this is not used directly (cpp2any is smart enough to not generate
    calls to the translation functions for the primitive types), it is still
    needed as it is used by container translation code.
 */
template <>
struct Translate<bool>
{
    typedef jboolean JNIType;
    typedef bool CppType;

    static CppType From(JNI::Env& /* env */, JNIType jvalue)
    {
        return jvalue == JNI_TRUE;
    }

    static JNIType To(JNI::Env& /* env */, CppType value)
    {
        return value;
    }
};

template <>
struct Translate<size_t>
{
    typedef jlong JNIType;
    typedef size_t CppType;

    static CppType From(JNI::Env& /* env */, JNIType jvalue)
    {
        return static_cast<CppType>(jvalue);
    }

    static JNIType To(JNI::Env& /* env */, CppType value)
    {
        return static_cast<JNIType>(value);
    }
};

#define JNI_DEFINE_TRANSLATION(Type)                                          \
    template <>                                                               \
    struct Translate<JNI::JTypeTraits<JNI_JTYPE(Type)>::ctype>                \
    {                                                                         \
        typedef JNI_JTYPE(Type) JNIType;                                      \
        typedef JNI::JTypeTraits<JNIType>::ctype CppType;                     \
                                                                              \
        static CppType From(JNI::Env& /* env */, JNIType jvalue)              \
        {                                                                     \
            return jvalue;                                                    \
        }                                                                     \
                                                                              \
        static JNIType To(JNI::Env& /* env */, CppType value)                 \
        {                                                                     \
            return value;                                                     \
        }                                                                     \
    }

JNI_DEFINE_TRANSLATION(Byte);
JNI_DEFINE_TRANSLATION(Char);
JNI_DEFINE_TRANSLATION(Short);
JNI_DEFINE_TRANSLATION(Int);
JNI_DEFINE_TRANSLATION(Long);
JNI_DEFINE_TRANSLATION(Float);
JNI_DEFINE_TRANSLATION(Double);

#undef JNI_DEFINE_TRANSLATION


/**
    Specialization for shared pointers.
 */
template <typename T>
struct Translate< shared_ptr<T> >
{
    typedef shared_ptr<T> CppType;
    typedef jobject JNIType;

    static shared_ptr<T> From(JNI::Env& env, jobject obj)
    {
        if ( !obj )
            throw EXCEPTION_MSG(ITO33_NULL_PARAM, "Object is null.");

        JNI::FieldId<jlong> idSelf("m_self");
        const jlong ptr = env.GetLongField(obj, idSelf);

        // Java object keeps a shared pointer containing the real object
        return *reinterpret_cast<shared_ptr<T> *>(ptr);
    }

    static jobject To(JNI::Env& env, const shared_ptr<T>& ptr)
    {
        JNI::JClass cls(env, TypeInfo<T>::GetFullName());
        JNI::MethodIdAny idCtor(env, cls, "<init>", "(J)V");

        return env.NewObject(cls, idCtor, reinterpret_cast<jlong>(&ptr));
    }
};

/**
    Specialization for auto pointers.
 */
template <typename T>
struct Translate< std::auto_ptr<T> >
{
    typedef std::auto_ptr<T> CppType;
    typedef jobject JNIType;

    // From() doesn't exist: it is impossible to create auto_ptr<> from an
    // existing object without destroying it

    static jobject To(JNI::Env& env, std::auto_ptr<T>& ptr)
    {
        typedef shared_ptr<T> ShPtr;

        return Translate< ShPtr >::To(env, ShPtr(ptr.release()));
    }
};

/**
    Specialization for strings.
 */
template <>
struct Translate<std::string>
{
    typedef std::string CppType;
    typedef jstring JNIType;

    static std::string From(JNI::Env& env, jstring s)
    {
        // FIXME: decode UTF8
        JNI::JStringChars chars(env, s);

        return std::string(chars);
    }

    static jstring To(JNI::Env& env, const std::string& str)
    {
        // of course, it's not really UTF so this actually only works for 7 bit
        // ASCII right now (FIXME)
        return env.NewStringUTF(str.c_str());
    }
};

/**
    Specialization for dates.
 */
template <>
struct TypeInfo<Date>
{
    static const char *GetFullName() { return "Ljava/util/Date;"; }
};

template <>
struct Translate<Date>
{
    typedef Date CppType;
    typedef jobject JNIType;

    // java.util.Date uses milliseconds, hence the 1000 factor
    enum { JAVATICKS_PER_DAY = 1000*60*60*24 };

    // the JDN of the Unix Epoch
    enum { EPOCH_JDN = 2440588 };

    static const char *JavaDateClass() { return "Ljava/util/Date;"; }

    static std::auto_ptr<Date> From(JNI::Env& env, jobject jdate)
    {
        if ( !jdate )
            throw EXCEPTION_MSG(ITO33_NULL_PARAM, "Date object is null.");

        // get the value from jdate
        JNI::JClass cls(env, JavaDateClass());
        JNI::MethodIdAny idGetTime(env, cls, "getTime", "()J");

        const jlong msec = env.CallLongMethod(jdate, idGetTime);

        // we may not convert Java time to time_t if time_t is only 32bit as we
        // risk overflow in 2038, so instead convert it to (entire) days and do
        // the addition to the Unix Epoch (from which Java counts too) manually
        std::auto_ptr<Date> date(new Date());
        date->SetJDN(EPOCH_JDN +
                        (unsigned long)(
                            (msec + JAVATICKS_PER_DAY/2) / JAVATICKS_PER_DAY));

        return date;
    }

    static jobject To(JNI::Env& env, const Date& date)
    {
        JNI::JClass cls(env, JavaDateClass());
        JNI::MethodIdAny idCtor(env, cls, "<init>", "(J)V");

        const jlong msec = (jlong)(date.GetJDN() - EPOCH_JDN)*JAVATICKS_PER_DAY;

        // we need to use local time when constructing Java data object so we
        // need to use the standard functions but they only work for the dates
        // in time_t range, so bring the date in this range supposing that the
        // DST rules don't depend on the year, just to get the TZ offset
        time_t tUTC = Date(1976, date.GetMonth(), date.GetDay()).GetTicks();
        time_t tLocal = mktime(gmtime(&tUTC));

        return env.NewObject(cls, idCtor, msec + (tLocal - tUTC)*1000);
    }
};

/**
    Specialization for vectors of objects.
 */
template <typename T>
struct Translate< std::vector<T> >
{
    typedef T ElementType;
    typedef std::vector<ElementType> CppType;
    typedef jobjectArray JNIType;

    static CppType From(JNI::Env& env, JNIType jarr)
    {
        if ( !jarr )
            throw EXCEPTION_MSG(ITO33_NULL_PARAM, "Array object is null.");

        JNI::JArray<jobject> array(env, jarr);

        const jsize len = array.GetLength();
        CppType vec;

        vec.reserve(len);

        for ( jsize n = 0; n < len; ++n ) {
            vec.push_back(*Translate<ElementType>::From(env, array.Get(n)));
        }

        return vec;
    }

    static JNIType To(JNI::Env& env, const CppType& vec)
    {
        JNI::JClass cls(env, TypeInfo<ElementType>::GetFullName());
        const size_t len = vec.size();
        JNI::JArray<jobject> array(env, len, cls);
        for ( size_t n = 0; n < len; ++n ) {
            array.Set(n, Translate<ElementType>::To(env, vec[n]));
        }

        return array.GetJArray();
    }
};

/**
    Specialization for lists of objects.
 */
template <typename T>
struct Translate< std::list<T> >
{
    typedef T ElementType;
    typedef std::list<ElementType> CppType;
    typedef jobjectArray JNIType;

    static CppType From(JNI::Env& env, JNIType jarr)
    {
        if ( !jarr )
            throw EXCEPTION_MSG(ITO33_NULL_PARAM, "Array object is null.");

        JNI::JArray<jobject> array(env, jarr);

        CppType lst;

        const jsize len = array.GetLength();
        for ( jsize n = 0; n < len; ++n ) {
            lst.push_back(*Translate<ElementType>::From(env, array.Get(n)));
        }

        return lst;
    }

    static JNIType To(JNI::Env& env, const CppType& lst)
    {
        JNI::JClass cls(env, TypeInfo<ElementType>::GetFullName());

        JNI::JArray<jobject> array(env, lst.size(), cls);
        jsize n = 0;
        for ( typename CppType::const_iterator i = lst.begin(),
                                             end = lst.end();
              i != end;
              ++i, ++n ) {
            array.Set(n, Translate<ElementType>::To(env, *i));
        }

        return array.GetJArray();
    }
};


/**
    Specialization for containers of primitive types.

    Note that we unfortunately can't use memcpy() here as sizes of C and Java
    types are not always the same. Worse, we can't use std::copy<> neither as
    it results in tons of warnings when instantiated for char vectors with VC++
    7.1.
 */
#define JNI_DEFINE_VECTOR_TRANSLATION(Type)                                   \
template <>                                                                   \
struct Translate< std::vector<JNI::JTypeTraits<JNI_JTYPE(Type)>::ctype> >     \
{                                                                             \
    typedef JNI_JTYPE(Type) JElementType;                                     \
    typedef JNI::JTypeTraits<JElementType>::ctype CElementType;               \
    typedef std::vector<CElementType> CppType;                                \
    typedef JNI_ATYPE(Type) JNIType;                                          \
                                                                              \
    static CppType From(JNI::Env& env, JNIType jarr)                          \
    {                                                                         \
        if ( !jarr )                                                          \
            throw EXCEPTION_MSG(ITO33_NULL_PARAM, "Array object is null.");   \
                                                                              \
        JNI::JArray<JElementType> array(env, jarr);                           \
                                                                              \
        const jsize len = array.GetLength();                                  \
        CppType vec(len);                                                     \
        for ( jsize n = 0; n < len; ++n ) {                                   \
            vec[n] = Translate<CElementType>::From(env, array[n]);            \
        }                                                                     \
                                                                              \
        return vec;                                                           \
    }                                                                         \
                                                                              \
    static JNIType To(JNI::Env& env, const CppType& vec)                      \
    {                                                                         \
        const size_t len = vec.size();                                        \
        Array<JElementType> buf(len);                                         \
        for ( size_t n = 0; n < len; ++n ) {                                  \
            buf[n] = Translate<CElementType>::To(env, vec[n]);                \
        }                                                                     \
                                                                              \
        return JNI::CreateFillArray(env, len, buf.Get());                     \
    }                                                                         \
};

JNI_DO_FOR_ALL_PRIMITIVE_TYPES(JNI_DEFINE_VECTOR_TRANSLATION)

#undef JNI_DEFINE_VECTOR_TRANSLATION

} // namespace Java

} // namespace C2A

#endif // _ITO_JNI_C2A_H_
