/*!
 *
 * Copyright (c) CDC IXIS CM November 2003 Paris
 *
 *	\file Ran4.cpp
 *  \brief 
 *	\author  E. Benhamou
 *	\version 1.0
 *	\date March 2004
 */


#include "gpnumlib/ran4.h"
#include "gpbase/ostringstream.h"
#include <glob/expt.h>
#include <climits>	/// for floor

CC_BEGIN_NAMESPACE( ARM )

////////////////////////////////////////////////////
////////////////////////////////////////////////////
//////////	ARM_RandUniform_NRRan4  ////////////////
////////////////////////////////////////////////////
////////////////////////////////////////////////////


////////////////////////////////////////////////////
///	Class  : ARM_RandUniform_NRRan4
///	Routine: constructor
///	Returns: built object
///	Action : 
////////////////////////////////////////////////////
ARM_RandUniform_NRRan4::ARM_RandUniform_NRRan4(long seed)
:	ARM_UniformGenerator(), itsCurrentSeed(seed), itsOriginalSeed(seed)
{
	if(seed >= 0 )
	    throw Exception(__LINE__, __FILE__, ERR_INVALID_ARGUMENT,  
			"Initial Seed has to be negative!" );
};


////////////////////////////////////////////////////
///	Class  : ARM_RandUniform_NRRan4  
///	Routine: reset
///	Returns: void
///	Action : reset the random number generator
////////////////////////////////////////////////////
void ARM_RandUniform_NRRan4::reset( size_t dim, const ARM_GP_T_Vector<size_t>& nbOfPointsList, size_t factorNb )
{
	itsCurrentSeed = itsOriginalSeed;
}




////////////////////////////////////////////////////
///	Class  : ARM_RandUniform_NRRan4  
///	Routine: reset
///	Returns: void
///	Action : Pseudo-DES hashing of the 64-bit word (lword,irword). 
///				Both 32-bit arguments are returned hashed on all bits.
////////////////////////////////////////////////////
void ARM_RandUniform_NRRan4::Psdes(unsigned long *lword, unsigned long *irword)
{
#define NITER 4
	unsigned long i,ia,ib,iswap,itmph=0,itmpl=0;
	static unsigned long c1[NITER]={
		0xbaa96887L, 0x1e17d32cL, 0x03bcdc3cL, 0x0f33d1b2L};
	static unsigned long c2[NITER]={
		0x4b0f3b58L, 0xe874f0c3L, 0x6955c5a6L, 0x55a7ca46L};

	for (i=0;i<NITER;i++) {
		ia=(iswap=(*irword)) ^ c1[i];
		itmpl = ia & 0xffff;
		itmph = ia >> 16;
		ib=itmpl*itmpl+ ~(itmph*itmph);
		*irword=(*lword) ^ (((ia = (ib >> 16) |
			((ib & 0xffff) << 16)) ^ c2[i])+itmpl*itmph);
		*lword=iswap;
	}
#undef NITER
}



////////////////////////////////////////////////////
///	Class  : ARM_RandUniform_NRRan4
///	Routine: DrawOne
///	Returns: double
///	Action : do a next seed and get next number!
///		based on Numerical Recipess Ran4
///		see http://www.library.cornell.edu/nr/bookcpdf.html
///		(C) Copr. 1986-92 Numerical Recipes Software #$#]2
///
///		Returns a uniform random deviate in the range 0.0 to 1.0,generated by pseudo-DES (DESlike)
///		hashing of the 64-bit word (idums,idum),where idums was set by a previous call with
///		negative idum. Also increments idum. Routine can be used to generate a random sequence
///		by successive calls, leaving idum unaltered between calls; or it can randomly access the nth
///		deviate in a sequence by calling with idum = n. Different sequences are initialized by calls with
///		differing negative values of idum.
////////////////////////////////////////////////////

double ARM_RandUniform_NRRan4::DrawOne()
{
	unsigned long irword,lword;
	static long idums = 0;

	if (itsCurrentSeed < 0)
	{
		idums = -itsCurrentSeed;
		itsCurrentSeed=1;
	}
	
	irword=itsCurrentSeed;
	lword=idums;
	ARM_RandUniform_NRRan4::Psdes(&lword,&irword);
	++itsCurrentSeed;
	
	/// rescale between zero and one! using non platform dependent constant
	return (double) irword/(double) ULONG_MAX;
};


/////////////////////////////////////////////////////////////////
///	Class  : ARM_RandUniform_NRRan4
///	Routine: copy constructor, assignment operator
///	Returns: ARM_Object*
///	Action :
/////////////////////////////////////////////////////////////////
ARM_RandUniform_NRRan4::ARM_RandUniform_NRRan4( const ARM_RandUniform_NRRan4& rhs )
:	ARM_UniformGenerator( rhs ), 
	itsCurrentSeed( rhs.itsCurrentSeed ), 
	itsOriginalSeed( rhs.itsOriginalSeed )
{}


ARM_RandUniform_NRRan4& ARM_RandUniform_NRRan4::operator =(const ARM_RandUniform_NRRan4& rhs )
{
	if( this != & rhs )
	{
		ARM_UniformGenerator::operator =( rhs );
		itsCurrentSeed	= rhs.itsCurrentSeed;
		itsOriginalSeed	= rhs.itsOriginalSeed;
	}
	return *this;
}


////////////////////////////////////////////////////
///	Class  : ARM_RandUniform_NRRan4
///	Routine: desctructor (necessary even for pure virtual case)
///	Action : draw a vector of uniform random numbers
////////////////////////////////////////////////////
ARM_RandUniform_NRRan4::~ARM_RandUniform_NRRan4()
{}



/////////////////////////////////////////////////////////////////
///	Class  : ARM_RandUniform_NRRan4
///	Routine: Clone
///	Returns: ARM_Object*
///	Action :
/////////////////////////////////////////////////////////////////
ARM_Object* ARM_RandUniform_NRRan4::Clone() const
{
	return new ARM_RandUniform_NRRan4(*this);
}


CC_END_NAMESPACE()

///---------------------------------------------------------------------------
///---- End of file ----
