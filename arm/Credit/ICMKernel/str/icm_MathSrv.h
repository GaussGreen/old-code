/* Generated by Together */

#ifndef MATHSRV_H
#define MATHSRV_H

#include <math.h>


namespace ep{
/**
 * stereotype utility 
 */
class MathSrv {
    public:
		
		static double Max(double x, double y);
		static double Min(double x, double y);
		static double RNG(int& seed);
		static void RNG(int& seed,double* dest,int n) ;
		static void NR_ran0(long&seed,double*dest,int n); 
		
	
        /**
         * N(0,1) density 
         */
        static double norm(double x);
		static double NormalInv(double p, double m, double s);
		

        /**
         * N(0,1) distribution function 
         */
        static double cumNorm(double x);
		static double cumNormal(double x, double m, double s); // utilisée pour le rating
        static double invCumNorm(double alpha);
		static void invCumNorm(double*x,int n); 
		static double MoroNormSInv(double phi);


		static double gamma_coeff[6];
		static double gammln(double xx);

		// Loi Beta
		static double InvBeta(double p, double a, double b);
		static double BETACH(double a, double b, int seed);
};


inline double  ep::MathSrv::invCumNorm(double u)
{  
//---------------------------------------------------------------------------------------------
// The Inverse cumulative normal distribution function
// Peter J. Acklam Method.
// URL: http://www.math.uio.no/~jacklam/notes/invnorm

 const double
    a1 = -3.969683028665376e+01,
    a2 =  2.209460984245205e+02,
    a3 = -2.759285104469687e+02,
    a4 =  1.383577518672690e+02,
    a5 = -3.066479806614716e+01,
    a6 =  2.506628277459239e+00;
    
 const double
    b1 = -5.447609879822406e+01,
    b2 =  1.615858368580409e+02,
    b3 = -1.556989798598866e+02,
    b4 =  6.680131188771972e+01,
    b5 = -1.328068155288572e+01;
    
  const double
    c1 = -7.784894002430293e-03,
    c2 = -3.223964580411365e-01,
    c3 = -2.400758277161838e+00,
    c4 = -2.549732539343734e+00,
    c5 =  4.374664141464968e+00,
    c6 =  2.938163982698783e+00;
    
  const double
    d1 =  7.784695709041462e-03,
    d2 =  3.224671290700398e-01,
    d3 =  2.445134137142996e+00,
    d4 =  3.754408661907416e+00;
    
  // Limits of the approximation region.
  const double
    u_low   = 0.02425,
    u_high  = 1.0 - u_low;


  //msgTools::assert ( fabs(u-0.5)>=0.5, "u should belong to (0,1)");
    
  
  double z, r;

  
  // Rational approximation for the lower region. ( 0 < u < u_low )
  if( u < u_low ){
    z = sqrt(-2.0*log(u));
    z = (((((c1*z+c2)*z+c3)*z+c4)*z+c5)*z+c6) / ((((d1*z+d2)*z+d3)*z+d4)*z+1.0);
  }
  
  // Rational approximation for the central region. ( u_low <= u <= u_high )
  else if( u <= u_high ){
    z = u - 0.5;
    r = z*z;
    z = (((((a1*r+a2)*r+a3)*r+a4)*r+a5)*r+a6)*z / (((((b1*r+b2)*r+b3)*r+b4)*r+b5)*r+1.0);
  }
  
  // Rational approximation for the upper region. ( u_high < u < 1 )
  else {
    z = sqrt(-2.0*log(1.0-u));
    z = -(((((c1*z+c2)*z+c3)*z+c4)*z+c5)*z+c6) /  ((((d1*z+d2)*z+d3)*z+d4)*z+1.0);
  }

  // The relative error of the approximation has absolute value less
  // than 1.15e-9.  One iteration of Halley's rational method (third
  // order) gives full machine precision.

  //r = (cumNorm(z) - u) * sqrt(2*PI) * exp( 0.5 * z * z );	//	f(z)/df(z)
  //z -= r/(1+0.5*z*r);							//	Halley's method

  return z;
}

inline void ep::MathSrv::invCumNorm(double*x,int n)
{
	for (int i=0;i<n;i++) x[i]=invCumNorm(x[i]); 
}

}
#endif //MATHSRV_H