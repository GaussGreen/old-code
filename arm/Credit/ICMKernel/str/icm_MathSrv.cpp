/* Generated by Together */

#include "icm_MathSrv.h"
//#include "msgTools.h"

#include <exception>


//-------------------------------MAX et MIN --------------------------------------------------

double ep::MathSrv::Max(double x, double y)
{	
	double M = x;
	if (y>x) {M = y;}

	return M;
}


double ep::MathSrv::Min(double x, double y)
{
	double m = x;
	if (x>y) {m = y;}

	return m;
}


/*
//-------------------PI-----------------------------------------------------------------------

const double ep::MathSrv::PI= 3.14159265358979;
*/
//------------------Normal Distribution-------------------------------------------------------

double ep::MathSrv::norm(double x)
{
	double PI = 3.14159265358979;
	return (1.0/sqrt(2*PI)) * exp( -0.5 * (x*x) );
}



double ep::MathSrv::NormalInv( double p, double m, double s)
{
	double NormInv = 0.;
	double y = 0.;
	double t = 0.;
		
	if ((1.-p>0) && (1.-p<0.5))
	{
		t = sqrt( log(1/((1-p)*(1-p)) ));
		y = t - (2.515517 + 0.802853*t + 0.010328*t*t)/(1. + t * 1.432788 + t*t*0.189269 + t*t*t*0.001308);
	}
	else if (1.-p>0)
	{
		t = sqrt(log(1./(p*p)));
		y = t - (2.515517 + 0.802853*t + 0.010328*t*t)/(1. + t * 1.432788 + t*t*0.189269 + t*t*t*0.001308);
		y = -y;
	}
	
	NormInv = y*s + m;
	return NormInv;
}



//-----------------------Normale Cumulée ---------------------------------------------------------------
	

double ep::MathSrv::cumNorm(double d)
{
	double	t;
	double	z;	
	double 	ans;
	double poly;

	z = fabs(d/sqrt(2.));
	t = 1.0/(1.0+0.5*z);
	poly = 	     -1.26551223 +
			t * ( 1.00002368 +
			t * ( 0.37409196 +
			t * ( 0.09678418 +
    		t * (-0.18628806 +
			t * ( 0.27886807 +
			t * (-1.13520398 +
			t * ( 1.48851587 +
    		t * (-0.82215223 +
 			t *   0.17087277 ) ) ) ) ) ) ) );
	ans = t * exp( -z*z + poly);

	if (d<=0.0)
		ans = 0.5 * ans;
	else
		ans = 1.0 - 0.5 * ans;

	return ans;
}



double ep::MathSrv::cumNormal(double x, double m, double s)
{
	double cum_Norm = 0.;
	double y,t,xi = 0.;
	double PI = 3.1415926535879;

	if ((x - m) >=0)	{xi = (x-m)/s;}
	else				{xi = -(x-m)/s;}

	t = 1./(1. + 0.2316419 * xi);
	y = 1 - (0.31938153 * t - 0.356563782 *t*t + 1.781477937*t*t*t - 1.821255978*t*t*t*t + 1.330274429*t*t*t*t*t) * exp(-xi*xi/2)/sqrt(2*PI);

	if (x-m>0)
	{ cum_Norm = y;}
	else 
	{ cum_Norm = 1. - y;}

	return cum_Norm;
}






// ------------------------- Autre version de l'inverse de la cumNorm -------------------------

//  Replaces NormSInv for quasi-random sequences (eg Faure)
//  See Moro (1995)
double ep::MathSrv::MoroNormSInv(double phi)
{
	
	double resultat = 0.;

	const double
	a1 = 2.50662823884,
	a2 = -18.61500062529,
	a3 = 41.39119773534,
	a4 = -25.44106049637;
	const double
	b1 = -8.4735109309,
	b2 = 23.08336743743,
	b3 = -21.06224101826,
	b4 = 3.13082909833;
	const double
	c1 = 0.337475482272615,
	c2 = 0.976169019091719,
	c3 = 0.160797971491821,
    c4 = 2.76438810333863E-02,
	c5 = 3.8405729373609E-03,
	c6 = 3.951896511919E-04,
    c7 = 3.21767881768E-05,
	c8 = 2.888167364E-07,
	c9 = 3.960315187E-07;
    
	double y,p = 0.;
	   
    y = phi - 0.5;
	
	if (fabs(y)<0.42)
	{	
		p = y*y;
		p = y * (((a4 * p + a3) * p + a2) * p + a1) / ((((b4 * p + b3) * p + b2) * p + b1) * p + 1);
	}
	else
	{
		if (y > 0)	{p = log(-log(1 - phi));}
        if (y <= 0) {p = log(-log(phi));}
        p = c1 + p * (c2 + p * (c3 + p * (c4 + p * (c5 + p * (c6 + p * (c7 + p * (c8 + p * c9)))))));
        if (y <= 0) {p = -p;}
    }

    resultat = p;
	return resultat;
}




//---------------------------------------------------------------------------------------------
double
ep::MathSrv::gamma_coeff[6] = {
	76.18009172947146,-86.50532032941677,
	24.01409824083091,-1.231739572450155,
	0.1208650973866179e-2,-0.5395239384953e-5
};
// Gamma fct from Numerical
//---------------------------------------------------------------------------------------------
double
ep::MathSrv::gammln(double xx)
{
	double y(xx), x(xx);
	double tmp = x + 5.5;
	tmp -= (x+0.5)*log(tmp);
	double ser = 1.000000000190015;
	for (int j=0;j<=5;j++) ser += gamma_coeff[j]/++y;
	return -tmp + log(2.5066282746310005*ser/x);
}
//---------------------------------------------------------------------------------------------


//--------------------------------Loi BETA-----------------------------------------------------
double ep::MathSrv::InvBeta(double p, double a, double b)
{
	double Inv_beta = 0.;

	double l,y,h,w = 0.;

	if (p<1E-7)
	{	return Inv_beta;}
	else
	{
		if (p>.1-1E-7)
		{ 
			Inv_beta = 1.;
			return Inv_beta;
		}
	}
	y = invCumNorm(1. - p);
	l = (y*y - 3.)/6.;
	h = 2./(1./(2. * a - 1.) + 1./(2.*b -1.));
	w = y * sqrt(h + l)/h - (1./(2.*a - 1.) - 1./(2.*b - 1.)) * (l + 5./6. -2./3./h);
	Inv_beta = a/(a+b*exp(2.*w));

	return Inv_beta;
}


double ep::MathSrv::BETACH(double a, double b, int seed)
{
/*Generates a Beta deviate
	Inputs: The two parameters of a standard beta distribution
	Algorithm is faster than others (e.g. BETAFX) if a or b is greater than 1, but not
	very effecient if a+b is too large (as it relies on a rejection procedure).
*/
	double betach = 0.;

	double alpha, beta, gamma, U1, U2, v, w, s =0.;
	alpha = a + b;
	s = Min(a,b);

	if (s<=1.)	{beta = 1./s;}
	else		{beta = sqrt((alpha - 2.) / (2.*a*b -alpha));}

	gamma = a + 1./beta;

	U1 = RNG(seed);
	U2 = RNG(seed);
	v = beta * log(U1/(1. - U1));
	w = a * exp(v);
	
	while ( (alpha * log(alpha/(b+w)) + gamma*v -log(4.))<log(U1*U1*U2))
	{
		U1 = RNG(seed);
		U2 = RNG(seed);
		v = beta * log(U1/(1. - U1));
		w = a * exp(v);
	}


	betach = w/(b+w);
	return 	betach;
}


// ---------------------------------------------------------------------------------------------------
// ------------------- METHODE NUMERIQUE RNG ---------------------------------------------------------
double ep::MathSrv::RNG(int& seed)
{
	double resultat = 0.;
	double x,u,a, test = 0.;
	a = seed;

	test = a * 16807./2147483647.;
	if (test > 0)   // Fix = Floor
	{	x = (a * 16807.) - floor(test) * 2147483647;}
	else			// Fix = Floor + 1 
	{	x = (a * 16807.) - (floor(test) + 1) * 2147483647;}

	u = x/2147483647.;
	seed = x;
	resultat = u;

	return resultat;
}
// JLA: directly compute RNG for an array. 
void ep::MathSrv::RNG(int& seed,double* dest,int n)
{
	double seed_=seed; 
	for( int i=0;i<n;i++) 
	{
		// double resultat = 0.;
		// double x,u,a, test = 0.;
		// a = seed;
		double test = seed_ * 16807./2147483647.;
		if (test > 0)   // Fix = Floor
		{	seed_ = (seed_  * 16807.) - floor(test) * 2147483647;}
		else			// Fix = Floor + 1 
		{	seed_ = (seed_  * 16807.) - (floor(test) + 1) * 2147483647;}
		dest[i] = seed_/2147483647.;
		// seed = x;
		// resultat = u;
		// dest[i]=u; 
	}
	seed=seed_; 
}
void ep::MathSrv::NR_ran0(long&seed,double*dest,int n)
{
	const long IA=16807 ;
	const long IM=2147483647; 
	const double AM=1./IM; 
	const long IQ=127773; 
	const long IR=2836; 
	// const long MASK = 123459876 ;
	long k; 
	
	for(int i=0;i<n;i++) 
	{
		k=seed/IQ; 
		seed=IA*(seed-k*IQ)-IR*k; 
		if (seed<0) seed+=IM; 
		dest[i] =AM*seed; 
	}
}
