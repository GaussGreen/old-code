
#ifndef _CREDITMANAGERH
#define _CREDITMANAGERH


/*********************************************************************************/
/*! \class  CreditManager CreditManager.h "CreditManager.h"
 *  \author 
 *	\version 1.0
 *	\date   Sept 15 2004
 *	\brief  Credit Manager */
/***********************************************************************************/

#include "ICMKernel\pricer\icm_pricer_security.h"


#include "ARMKernel\inst\security.h"
#include "ICMKernel\inst\icm_mez.h"

#include "ARMKernel\crv\zerocurv.h"

#include "ICMKernel\util\icm_qmatrix.h"
#include "ICMKernel\util\icm_matrix.h"
#include "ICMKernel\util\icm_utils.h"

#include "ICMKernel\cair\types.h"

#include "ICMKernel\mod\modelmulticurves.h"
#include "ICMKernel\glob\icm_correlation.h"
#include "ICMKernel\util\icm_root_generator.h"

#include "ICMKernel\util\icm_qmatrix.h"

#include "ICMKernel\cair\ICM_Probability_Density.h"
#include "ICMKernel\cair\ICM_Credit_Manager_Calibrator.h"


#include "ICMKernel\mod\icm_customized_credit_multicurves.h"
#include "ICMKernel\inst\icm_customized_cdo.h"

#include <set>

#define	_size_creditlabel_	60
#define	_SIZE_CREDIT_MATURITIES_	10

#define	T_EPS	1e-3

#define	_MAX_LP_Degree_	5

class	ICM_Credit_Manager_Calibrator;
class ICM_CorrMatrix; 
class Tau_Item
{
	public:
		int		id;
		double	tau;
		double	cumul_loss;		// the current id excluded.
		int		cumul_nbdef;	// the current id excluded.
		double	loss_at_that_time;		// if it is an exact Default Time, otherwise 0.0

		// CDO Square
		double	cumul_loss_square;
		int		cumul_nbdef_square;

		double	prev_cumul_loss_square;	// the current id is excluded
		double	equiv_current_loss_square;	// the extra loss generated by this id

		DoubleVector	cumul_loss_CDOs;		// for all Underlying CDOs
		DoubleVector	cumul_nbdef_CDOs;		// for all Underlying CDOs

		DoubleVector	tranche_losses_CDOs;
	
	public:

		Tau_Item()
		{
			Init();

		}

//		Tau_Item(Tau_Item& data);


		Tau_Item(const Tau_Item& data)
		{
			int	the_size	=	data.cumul_loss_CDOs.size();;

			Init();

			id	=	data.id;
			tau	=	data.tau;
			cumul_loss	=	data.cumul_loss;
			cumul_nbdef	=	data.cumul_nbdef;
			loss_at_that_time	=	data.loss_at_that_time;

			cumul_loss_CDOs.resize(the_size);
			cumul_nbdef_CDOs.resize(the_size);
			tranche_losses_CDOs.resize(the_size);

			cumul_loss_CDOs		=	data.cumul_loss_CDOs;
			cumul_nbdef_CDOs	=	data.cumul_nbdef_CDOs;
			tranche_losses_CDOs	=	data.tranche_losses_CDOs;

			prev_cumul_loss_square	=	data.prev_cumul_loss_square;
			equiv_current_loss_square		=	data.equiv_current_loss_square;
		}

		Tau_Item(int i, double d, double c_l = 0.0, int c_n = 0, double l_t = 0.0, double c_l_s = 0.0, int c_n_s = 0, double p_c_l_s = 0.0, double e_c_l_s = 0.0): 
          id(i), tau(d), cumul_loss(c_l), cumul_nbdef(c_n), loss_at_that_time(l_t), cumul_loss_square(c_l_s), cumul_nbdef_square(c_n_s), prev_cumul_loss_square(p_c_l_s), equiv_current_loss_square(e_c_l_s)
			{
			  cumul_loss_CDOs.clear(); cumul_nbdef_CDOs.clear(); tranche_losses_CDOs.clear();}

		~Tau_Item(void)
		{
			cumul_loss_CDOs.clear();
			cumul_nbdef_CDOs.clear();
			tranche_losses_CDOs.clear();
		}

	public:

		bool operator < (const Tau_Item & rhs) const {
			return tau < rhs.tau;
		}
		
		bool operator == (const Tau_Item & rhs) const {
			return tau == rhs.tau;
		}
		
	protected:

		void Init()
		{
			id	= 0;
			tau	=	0.0;
			cumul_loss	=	0.0;
			cumul_nbdef	=	0;
			loss_at_that_time	=	0.0;

			cumul_loss_square	=	0.0;
			cumul_nbdef_square	=	0;

			prev_cumul_loss_square		=	0.0;
			equiv_current_loss_square			=	0.0;

			cumul_loss_CDOs.clear();
			cumul_nbdef_CDOs.clear();
			tranche_losses_CDOs.clear();

		}
};



class CreditManager : public ICM_Pricer_Security
{

	// ----------------------------------------------------------
	// DATA
	// ----------------------------------------------------------

    private:

		bool			itsActivateFlag;

		ARM_Date		itsValDate;		// AsOfDate
		double			itsValDateAsDouble;
		
		ARM_Date		itsMaxCDSDate;	// MaxCDSDate --> will have to take PayLag into account

		// PreComputes the ZC Values for CDS Calibration
		ARM_Vector*		itsZCValuesForCalibration;

		double			itsElapsed_Time;	// to monitor the time

	// ----------------------------------------------------------
	// ----------------------------------------------------------
    
	public:

        CreditManager(void) {Init();}

		CreditManager(ARM_Security *option, ARM_Model *mod, const ICM_Parameters& parameters ,const ARM_Date&asof)
		{
			Init();

			Set(option, mod, parameters,asof);
		}


/*        void BitwiseCopy(const ARM_Object* src);

        void Copy(const ARM_Object* srcZc);
 
        ARM_Object* Clone(void)
        {
            CreditManager* theClone = new CreditManager();
 
             theClone->Copy(this);
 
            return(theClone);
        }
*/

		~CreditManager(void) ; 

        void Init(void);

		virtual void Reset();

		void Set(ARM_Security *option, ARM_Model *mod, const ICM_Parameters&parameters ,const ARM_Date&asof);

	// ----------------------------------------------------------
	// SPECIFIC CLASS IMPLEMENTATION
	// ----------------------------------------------------------

	public :
		
		inline bool IsActivated(void) { return itsActivateFlag;}
		inline void SetActivateFlag(bool ActivateFlag) { itsActivateFlag = ActivateFlag;}

		inline void	SetValDate(const ARM_Date& ValDate) {itsValDate = ValDate; }
		inline ARM_Date GetValDate(void) { return itsValDate;}

		inline void	SetMaxCDSDate(const ARM_Date& ValDate) {itsMaxCDSDate = ValDate; }
		inline ARM_Date GetMaxCDSDate(void) { return itsMaxCDSDate;}

		inline void SetZCValuesForCalibration(ARM_Vector* zc) 
		{
			if (itsZCValuesForCalibration) 
				delete itsZCValuesForCalibration;
			itsZCValuesForCalibration = zc; 
		}

		inline ARM_Vector* GetZCValuesForCalibration(void) { return itsZCValuesForCalibration;}

		inline void	SetElasped_Time(double elapsed_time) {itsElapsed_Time = elapsed_time; }
		inline double GetElasped_Time(void) { return itsElapsed_Time;}

		double	DiscountPrice(int i);

		void Display();
/*
	public:
		
		void TestSolver();

	public:
		ReturnCode CalibrationFunction(double& Result);
		ReturnCode ExtractCurrentCalibration(DoubleVector& CalibrationVector);

		DoubleVector	The_Targets;
		DoubleMatrix	The_Coeffs;

		DoubleVector	ThePoint;
*/
		// --------------------------------------------------------------------------
		// --------------------------------------------------------------------------

		// --------------------------------------------------------------------------

	private:

		ICM_ModelMultiCurves*		its_ModelMultiCurves;
		
		// --------------------------------------------------------------------------
		// Market Data
		// --------------------------------------------------------------------------
		ARM_ZeroCurve*		its_ZeroCurve;				// from Summit
		bool				its_ImposedIRCurveFlag;

		IntVector		its_IR_Lags;
		DoubleVector	its_IR_ZC_Yields;
		// --------------------------------------------------------------------------

	public:

		inline	ARM_ZeroCurve* GetZeroCurve() {return its_ZeroCurve;}
		void	SetZeroCurve(ARM_ZeroCurve* crv);

		inline bool IsImposedIRCurve(void) { return its_ImposedIRCurveFlag;}
		inline void SetImposedIRCurveFlag(bool ImposedIRCurveFlag) {its_ImposedIRCurveFlag = ImposedIRCurveFlag;}

		// Set Cash Flows Matrix
		void  SetMarketDataParameters(ICM_Matrix<ARM_Vector>* parameters);
		void  SetImposedIRCurves(ICM_Matrix<ARM_Vector>* parameters);

		void	Get_IR_Lags(IntVector& data)	{data = its_IR_Lags;}
		void	Set_IR_Lags(const IntVector& data)	{its_IR_Lags	=  data;}
		
		void	Get_IR_ZC_Yields(DoubleVector& data)	{data = its_IR_ZC_Yields;}
		void	Set_IR_ZC_Yields(const DoubleVector& data)	{its_IR_ZC_Yields= data;}

		bool	IsHomogeneousBasket() {return its_IsHomogeneousBasket;}
		bool	IsHeterogenousBasket() {return !its_IsHomogeneousBasket;}

		bool	IsHomogeneousBasketLossUnit() {return its_IsHomogeneousBasketLossUnit;}
		bool	IsHeterogenousBasketLossUnit() {return !its_IsHomogeneousBasketLossUnit;}

		// whether to do redo GenerateAllDefaultCurves() or not!
		bool	KeepCalibration() {return its_KeepCalibrationFlag;}
		bool	DoCalibration() {return !its_KeepCalibrationFlag;}


	private:
		
		// --------------------------------------------------------------------------
		// Credit Data
		// --------------------------------------------------------------------------
		StringVector	its_CreditsLabels;			//Vector of Labels
		//char**			its_CreditsLabelsAsChar;	// labels

		bool			its_RollDateFlag;			// use Roll Dates or Not
		bool			its_KeepCalibrationFlag;	// Keep Calibrated Data? or Not

		CreditHedgeBump	its_Bump_Choice;
		
		double			its_BumpSpread;			// Bump Spread Value
		BumpType		its_BumpSpread_Type;	// Enum Type Add or Mult
		double			its_BumpRecovery;			// Bump Recovrery Value (in %: 0.10 for 10ù)
		double			its_BumpCorrelation;		// Bump Correlation Value (in %: 0.10 for 10ù)


		ICM_QMatrix<double>*	its_CreditDataSpreads;			// Credit Data Spreads

	
		// Credit Data Description
		vector<CreditCategory>			its_Categories;			// Sectorial or Geographical Category
		vector<CurrencyName>			its_Currencies;			// Currencies

		IntVector			its_Accrueds;			// Accrued Flags
		DoubleVector		its_Recoveries;			// Recoveries
		DoubleVector		its_Notionals;			// Notionals
		DoubleVector		its_Input_Losses;				// Losses
		DateVector			its_DefaultDates;		// Imposed Default Dates
		DateVector			its_AmortizationDates;		// Imposed Amortization Dates

		// Number of maturities
		StringVector		its_Maturities;
//		char**				its_Maturities_AsChar;
		char				its_Maturities_AsChar[ARM_NB_TERMS][ARM_NB_MAX_CHAR_TERMS];
		double				its_LastPricingDate;

		bool				its_IsHomogeneousBasket;			// with Spreads
		bool				its_IsHomogeneousBasketLossUnit;	// only Ni * (1.0 - Ri)

	public:

		int	Get_NbCredits() const	{return its_CreditsLabels.size();}

		void  SetCreditDataParameters(ICM_Matrix<ARM_Vector>* parameters);
		void  SetCreditDataDescription(ICM_Matrix<ARM_Vector>* parameters);

		void Set_CreditDataSpreads(ICM_QMatrix<double>* value) 
		{ 
			if (its_CreditDataSpreads)
				delete its_CreditDataSpreads;
			its_CreditDataSpreads = value; 
		}

		ICM_QMatrix<double>* Get_CreditDataSpreads(void) { return its_CreditDataSpreads;}

		void	Get_Categories(vector<CreditCategory>& data)	{data = its_Categories;}
		void	Set_Categories(const vector<CreditCategory>& data)	{its_Categories = data;}

		void	Get_Currencies(vector<CurrencyName>& data)	{data = its_Currencies;}
		void	Set_Currencies(const vector<CurrencyName>& data)	{its_Currencies = data;}

		void	Get_Accrueds(IntVector& data)	{data = its_Accrueds;}
		void	Set_Accrueds(const IntVector& data)	{its_Accrueds = data;}

		void	Get_Recoveries(DoubleVector& data)	{data = its_Recoveries;}
		void	Set_Recoveries(const DoubleVector& data)	{its_Recoveries = data;}

		void	Get_Notionals(DoubleVector& data)	{data = its_Notionals;}
		void	Set_Notionals(const DoubleVector& data)	{its_Notionals= data;}
		
		void	Get_Losses(DoubleVector& data)	{data = its_Input_Losses;}
		void	Set_Losses(const DoubleVector& data)	{its_Input_Losses= data;}

		void	Get_DefaultDates(DateVector& data)	{data = its_DefaultDates;}
		void	Set_DefaultDates(const DateVector& data)	{its_DefaultDates = data;}

		void	Get_AmortizationDates(DateVector& data)	{data = its_AmortizationDates;}
		void	Set_AmortizationDates(const DateVector& data)	{its_AmortizationDates = data;}

		void	Get_CreditsLabels(StringVector& data)	{data = its_CreditsLabels;}
		void	Set_CreditsLabels(const StringVector& data)	{its_CreditsLabels = data;}
		//void	Set_CreditsLabelsAsChar(char** data);
		//void	Set_CreditsLabelsAsChar(const std::vector<std::string>& data);

		int	Get_NbMaturities() const	{return its_Maturities.size();}

		void	Get_CreditDataMaturities(StringVector& data)	{data = its_Maturities;}
		void	Set_CreditDataMaturities(const StringVector& data)	{its_Maturities = data;}
//		void	Set_CreditDataMaturitiesAsChar(char** data);
		void	Set_CreditDataMaturitiesAsChar(char data[ARM_NB_TERMS][ARM_NB_MAX_CHAR_TERMS]);

		// -----------------------------------------------------------------------------

	private:

			// Pricer Data
			int			its_NbSimul;							// Number of Simulations
			
			CreditCopulaType	its_CopulaType;						// Copula Choice
			CorrelationType		its_CorrelationType;				// Correlation Choice
			CreditModelType		its_CreditModelType;				// Model (Numerical) Type

			int			its_FreedomDegree;						// Student Freedom Degree
			double		its_CorrelationValue;

			DoubleVector		its_Beta;
			DoubleVector		its_Base_Correlation_Strikes;
			DoubleVector		its_Base_Correlation_Values;

//			double**			itsCorrelationMatrix;
			ICM_CorrMatrix*			its_CorrelationMatrix;			// Correlation Matrix Object
			ICM_QMatrix<double>*	its_CholeskyMatrix;				// matrice de cholesky

			ICM_Correlation*   itsCorrelation;		//Correlation object

			// ------------------------------------------------
			// FACTOR LOADING
			// ------------------------------------------------

			Correlation_RFL		its_Correlation_RFL_Type;

			DoubleVector		its_FL_Alpha;
			DoubleVector		its_FL_Beta1;
			DoubleVector		its_FL_Beta2;

			DoubleVector		its_FL_Beta1_Complement;
			DoubleVector		its_FL_Beta2_Complement;

			DoubleVector		its_Used_Beta;
			DoubleVector		its_Used_SQRT_OneMinusBetaSquare;

			// ------------------------------------------------
			// FACTOR LOADING: TANH
			// ------------------------------------------------

			// a(z)	=	TANH(alpha + delta * TANH(theta * z + mu))

			double			its_FL_TanH_alpha;
			double			its_FL_TanH_delta;
			double			its_FL_TanH_theta;
			double			its_FL_TanH_mu;

			// ------------------------------------------------


			// One FACTOR Modelling
			int		its_NIntegration_1F;

			//	FFT Half Number of Points
			int		its_N_FFT;

			// RECURSIVE
			CreditOneFactorRecursiveLossUnitChoice		its_Recursive_1F_Loss_Unit_Choice;

			double			its_LossUnit;
			IntVector		its_LossRate;
			
			double			its_Recursive_1F_Loss_Unit_Min;
			int				its_Recursive_1F_NbLossStep;

			// ------------------------------------------------
			// LHP
			// ------------------------------------------------
			RelativeDate		its_LHP_Maturity;
			double				its_LHP_Spread;		// in bps
			double				its_LHP_Recovery;

			ICM_DefaultCurve*	its_DefCurve;

	private:

		// FACTOR LOADING
		void	Allocation_RFL_Correlation_Data();


		// ONE FACTOR MODEL

		// HULL ALGORITHM - APPENDIX A: case of an homogeneous portfolio

		//	Computes Probability that at time T we have more than Nth to Default (included)
		void	ProbabilityOfAtLeastNDefaultBeforeT_1F(double T, int NtD, double& Result);
		void	ProbabilityOfNDefaultsBeforeT_1F(double	T, int NtD, DoubleVector& Result);
		void	CumulativeBinomialDistibutionNumbers(DoubleVector& p, DoubleVector& Qk);

		
		void	PortfolioLoss_FFT(DoubleVector& DefProb, DoubleVector& ProbaDensityFunctionLossDistribution);
		void	PortfolioLoss_CharacteristicFunction(double u, DoubleVector& DefProb, double& psi_r, double& psi_i);
		void	GetLossFromPDF_Distribution(CreditLossComputation ProbOrExpectationFlag, double LossMin, double LossMax, DoubleVector& PDF_Loss_Distribution, double& Prob_Loss);
		
		void	ComputeProbabilityOrExpectationLossesBeforeT_FFT_1F(double	T, CreditLossComputation ProbOrExpectationFlag, double LossMin, double LossMax, DoubleVector& Result);
		void	ComputeProbabilityOrExpectationLossesBeforeT_RECURSIVE_1F(double	T, CreditLossComputation ProbOrExpectationFlag, double LossMin, double LossMax, double& Result);
		void	ComputeProbabilityOrExpectationLossesBeforeT_RECURSIVE_STOCHASTIC_CORRELATION_BERNOULLI_1F(double T, CreditLossComputation ProbOrExpectationFlag, double LossMin, double LossMax, double& Result);
		void	ComputeProbabilityOrExpectationLossesBeforeT_RECURSIVE_RFL(double T, CreditLossComputation ProbOrExpectationFlag, double LossMin, double LossMax, double& Result);
		
		// hedges
		void	ComputeProbabilityOrExpectationLossesBeforeT_RECURSIVE_1F_Hedges_Spread(double	T, CreditLossComputation ProbOrExpectationFlag, double LossMin, double LossMax, double& Result);

	public:

		void	Get_CorrelationValue(double&	data)	{data	=	its_CorrelationValue;}
		void	Set_CorrelationValue(const double&	data)	{its_CorrelationValue	=	data;}

		void	Get_Beta(DoubleVector& data)	{data = its_Beta;}
		void	Set_Beta(const DoubleVector& data)	{its_Beta= data;}

		void	Get_FL_Alpha(DoubleVector& data)	{data = its_FL_Alpha;}
		void	Set_FL_Alpha(const DoubleVector& data)	{its_FL_Alpha= data;}

		void	Get_FL_Beta1(DoubleVector& data)	{data = its_FL_Beta1;}
		void	Set_FL_Beta1(const DoubleVector& data)	{its_FL_Beta1= data;}

		void	Get_FL_Beta2(DoubleVector& data)	{data = its_FL_Beta2;}
		void	Set_FL_Beta2(const DoubleVector& data)	{its_FL_Beta2= data;}

		void	Get_Base_Correlation_Strikes(DoubleVector& data)	{data = its_Base_Correlation_Strikes;}
		void	Set_Base_Correlation_Strikes(const DoubleVector& data)	{its_Base_Correlation_Strikes= data;}

		void	Get_Base_Correlation_Values(DoubleVector& data)	{data = its_Base_Correlation_Values;}
		void	Set_Base_Correlation_Values(const DoubleVector& data)	{its_Base_Correlation_Values= data;}

		// Set Cash Flows Matrix
		void	SetCreditModelParameters(ICM_Matrix<ARM_Vector>* parameters);

		// Correlation Object (no clone)
		void	SetCorrelation(ICM_Correlation* correl) {itsCorrelation = (ICM_Correlation*) correl->Clone();}

		ICM_CorrMatrix*	Get_CorrelationMatrix(void) { return its_CorrelationMatrix;}
		ICM_QMatrix<double>*	Get_CholeskyMatrix(void) { return its_CholeskyMatrix;}

		void	Set_CorrelationMatrix(ICM_CorrMatrix* correlmatrix) ;

		void	CholeskyComputation();
			
		// -----------------------------------------------------------------------------
		// Set Factor Loadings Matrix
		void	SetFactorLoadingsParameters(ICM_Matrix<ARM_Vector>* parameters);

	private:
		
		// -----------------------------------------------------------------
		// Default Leg Data
		RelativeDate	its_DL_CreditWindowLow;			// Credit Observation Window Low
		RelativeDate	its_DL_CreditWindowUp;			// Credit Observation Window High
		double			its_DL_LossMin;					// Credit Loss Min
		double			its_DL_LossMax;					// Credit Loss Max
		int				its_DL_NbDefMin;					// Credit Nb Def Min
		int				its_DL_NbDefMax;					// Credit Nb Def Max
		CreditEventPayment	its_DL_PaymentType;				// Credit Payment (Default, Maturity, etc.)
		RelativeDate	its_DL_PaymentDate;					// if required the Date
		int				its_DL_PaymentLag;					// the lag
		// -----------------------------------------------------------------


		// -----------------------------------------------------------------
		// Premium Leg Data
		
		// first Vectors
		DateVector		its_PL_CreditWindowLows;			// Credit Observation Window Low
		DateVector		its_PL_CreditWindowUps;			// Credit Observation Window Low
		DateVector		its_PL_StartDates;					// Start Dates for Period
		DateVector		its_PL_EndDates;					// End Dates for Period
		DateVector		its_PL_PaymentDates;				// Payment Dates for Period

		DateVector		its_PL_CreditWindowUps_DF;
		DateVector		its_PL_PaymentDates_DF;

		DoubleVector	its_PL_LossMins;
		DoubleVector	its_PL_LossMaxs;
		DoubleVector	its_PL_NbDefMins;
		DoubleVector	its_PL_NbDefMaxs;
		DoubleVector	its_PL_Ratios;
		DoubleVector	its_PL_Notios;
		DoubleVector	its_PL_Spreads;

		vector<CreditPremiumLegType>		its_PL_CreditFlags;		// Guaranteed, Fix Nominal, Outstanding Nominal
		DoubleVector	its_PL_CreditSpreadCaps;
		DoubleVector	its_PL_Redemptions;

		// sorted
		DateVector		its_PL_Sorted_PaymentDates;				// Payment Dates for Period
		DateVector		its_PL_Sorted_CreditWindowUps;			// Credit Observation Window Low
		DoubleVector	its_PL_Sorted_CreditWindowUps_DF;
		DoubleVector	its_PL_Sorted_PaymentDates_DF;
		
		CreditEventPayment		its_PL_PaymentType;			// only in case of Prorata

		// second Values
	private:

		int				its_PL_NbFlows;

		int				its_CurrentIndex;
		int				its_SimulId;
		int				its_iFlow;

		RelativeDate	its_PL_CreditWindowLow;
		RelativeDate	its_PL_CreditWindowUp;
		RelativeDate	its_PL_StartDate;
		RelativeDate	its_PL_EndDate;
		RelativeDate	its_PL_PaymentDate;

		double			its_PL_LossMin;
		double			its_PL_LossMax;
		double			its_PL_NbDefMin;
		double			its_PL_NbDefMax;
		double			its_PL_Ratio;
		double			its_PL_Notio;
		double			its_PL_Spread;

		CreditPremiumLegType	its_PL_CreditFlag;
		double			its_PL_CreditSpreadCap;
		double			its_PL_Redemption;
		// -----------------------------------------------------------------

		// Specific Credit TARN
		double			its_Cumulative_Coupon;
		double			its_Last_Coupon;
		double			its_Last_FlowForATMMargin;
		bool			its_Toggle_Redemption;
		bool			its_Final_Redemption;

		// -----------------------------------------------------------------
		// Max Values from DATA

		int				its_Useful_MaxNbDef;
		double			its_Useful_MaxLoss;

	// ----------------------------------------------------
	//	Methods to deal with Attributes
	// ----------------------------------------------------

	// Pricer Data

	void	Get_CopulaType(CreditCopulaType& data)	{data = its_CopulaType;}
	void	Set_CopulaType(const CreditCopulaType& data)	{its_CopulaType = data;}

	void	Get_CorrelationType(CorrelationType& data)	{data = its_CorrelationType;}
	void	Set_CorrelationType(const CorrelationType& data)	{its_CorrelationType = data;}

	void	Get_ModelType(CreditModelType& data)	{data = its_CreditModelType;}
	void	Set_ModelType(const CreditModelType& data)	{its_CreditModelType = data;}

	void	Get_NbSimul(int& data)	{data = its_NbSimul;}
	void	Set_NbSimul(const int& data)	{its_NbSimul= data;}
	
	void	Get_FreedomDegree(int& data)	{data = its_FreedomDegree;}
	void	Set_FreedomDegree(const int& data)	{its_FreedomDegree = data;}

	// Default Leg Data

	void	Get_DL_CreditWindowLow(RelativeDate& data)	{data = its_DL_CreditWindowLow;}
	void	Set_DL_CreditWindowLow(const RelativeDate& data)	{its_DL_CreditWindowLow = data;}

	void	Get_DL_CreditWindowUp(RelativeDate& data)	{data = its_DL_CreditWindowUp;}
	void	Set_DL_CreditWindowUp(const RelativeDate& data)	{its_DL_CreditWindowUp = data;}

	void	Get_DL_PaymentDate(RelativeDate& data)	{data = its_DL_PaymentDate;}
	void	Set_DL_PaymentDate(const RelativeDate& data)	{its_DL_PaymentDate = data;}

	void	Get_DL_LossMin(double& data)	{data = its_DL_LossMin;}
	void	Set_DL_LossMin(const double& data)	{its_DL_LossMin= data;}
	
	void	Get_DL_LossMax(double& data)	{data = its_DL_LossMax;}
	void	Set_DL_LossMax(const double& data)	{its_DL_LossMax= data;}

	void	Get_DL_PaymentLag(int& data)	{data = its_DL_PaymentLag;}
	void	Set_DL_PaymentLag(const int& data)	{its_DL_PaymentLag = data;}

	
	// Premium Leg Data
	void	Get_PL_CreditWindowLows(DateVector& data)	{data = its_PL_CreditWindowLows;}
	void	Set_PL_CreditWindowLows(const DateVector& data)	{its_PL_CreditWindowLows = data;}

	void	Get_PL_CreditWindowUps(DateVector& data)	{data = its_PL_CreditWindowUps;}
	void	Set_PL_CreditWindowUps(const DateVector& data)	{its_PL_CreditWindowUps = data;}

	void	Get_PL_StartDates(DateVector& data)	{data = its_PL_StartDates;}
	void	Set_PL_StartDates(const DateVector& data)	{its_PL_StartDates = data;}

	void	Get_PL_EndDates(DateVector& data)	{data = its_PL_EndDates;}
	void	Set_PL_EndDates(const DateVector& data)	{its_PL_EndDates = data;}

	void	Get_PL_PaymentDates(DateVector& data)	{data = its_PL_PaymentDates;}
	void	Set_PL_PaymentDates(const DateVector& data)	{its_PL_PaymentDates = data;}

	void	Get_PL_LossMins(DoubleVector& data)	{data = its_PL_LossMins;}
	void	Set_PL_LossMins(const DoubleVector& data)	{its_PL_LossMins= data;}
	
	void	Get_PL_LossMaxs(DoubleVector& data)	{data = its_PL_LossMaxs;}
	void	Set_PL_LossMaxs(const DoubleVector& data)	{its_PL_LossMaxs= data;}

	void	Get_PL_Ratios(DoubleVector& data)	{data = its_PL_Ratios;}
	void	Set_PL_Ratios(const DoubleVector& data)	{its_PL_Ratios = data;}

	void	Get_PL_Notios(DoubleVector& data)	{data = its_PL_Notios;}
	void	Set_PL_Notios(const DoubleVector& data)	{its_PL_Notios = data;}

	void	Get_PL_Spreads(DoubleVector& data)	{data = its_PL_Spreads;}
	void	Set_PL_Spreads(const DoubleVector& data)	{its_PL_Spreads = data;}
	
	void	Get_PL_CreditFlags(vector<CreditPremiumLegType>& data)	{data = its_PL_CreditFlags;}
	void	Set_PL_CreditFlags(const vector<CreditPremiumLegType>& data)	{its_PL_CreditFlags = data;}

	void	Get_PL_CreditSpreadCaps(DoubleVector& data)	{data = its_PL_CreditSpreadCaps;}
	void	Set_PL_CreditSpreadCaps(const DoubleVector& data)	{its_PL_CreditSpreadCaps = data;}

	void	Get_PL_Redemptions(DoubleVector& data)	{data = its_PL_Redemptions;}
	void	Set_PL_Redemptions(const DoubleVector& data)	{its_PL_Redemptions = data;}

	// internal data
	void	Get_PL_NbFlows(int& data)	{data = its_PL_NbFlows;}
	void	Set_PL_NbFlows(const int& data)	{its_PL_NbFlows = data;}

	void	Get_PL_CreditWindowLow(RelativeDate& data)	{data = its_PL_CreditWindowLow;}
	void	Set_PL_CreditWindowLow(const RelativeDate& data)	{its_PL_CreditWindowLow = data;}

	void	Get_PL_CreditWindowUp(RelativeDate& data)	{data = its_PL_CreditWindowUp;}
	void	Set_PL_CreditWindowUp(const RelativeDate& data)	{its_PL_CreditWindowUp = data;}

	void	Get_PL_PaymentDate(RelativeDate& data)	{data = its_PL_PaymentDate;}
	void	Set_PL_PaymentDate(const RelativeDate& data)	{its_PL_PaymentDate = data;}

	void	Get_PL_StartDate(RelativeDate& data)	{data = its_PL_StartDate;}
	void	Set_PL_StartDate(const RelativeDate& data)	{its_PL_StartDate = data;}

	void	Get_PL_EndDate(RelativeDate& data)	{data = its_PL_EndDate;}
	void	Set_PL_EndDate(const RelativeDate& data)	{its_PL_EndDate = data;}

	void	Get_PL_LossMin(double& data)	{data = its_PL_LossMin;}
	void	Set_PL_LossMin(const double& data)	{its_PL_LossMin= data;}
	
	void	Get_PL_LossMax(double& data)	{data = its_PL_LossMax;}
	void	Set_PL_LossMax(const double& data)	{its_PL_LossMax= data;}

	void	Get_PL_Ratio(double& data)	{data = its_PL_Ratio;}
	void	Set_PL_Ratio(const double& data)	{its_PL_Ratio = data;}

	void	Get_PL_Notio(double& data)	{data = its_PL_Notio;}
	void	Set_PL_Notio(const double& data)	{its_PL_Notio = data;}

	void	Get_PL_Spread(double& data)	{data = its_PL_Spread;}
	void	Set_PL_Spread(const double& data)	{its_PL_Spread = data;}

	void	Get_PL_CreditFlag(CreditPremiumLegType& data)	{data = its_PL_CreditFlag;}
	void	Set_PL_CreditFlag(const CreditPremiumLegType& data)	{its_PL_CreditFlag = data;}

	void	Get_PL_CreditSpreadCap(double& data)	{data = its_PL_CreditSpreadCap;}
	void	Set_PL_CreditSpreadCap(const double& data)	{its_PL_CreditSpreadCap = data;}
	

	// PRODUCT PARAMETERS
	private:

		// in order to know whether it is Def-Prem vs. Prem-Def or Prem or Def alone
		CreditBasketNPV			its_PricingLegsType;
		double					DefNPVFlag;
		double					PremNPVFlag;

		CreditObservation		its_CreditObservationType;	// Do observe Losses or Nb Defaults?
		CreditAccruedPayment	its_CreditPremiumLegAccrued;
		CreditPremiumLegATMData its_ATMDataFlag;

		CreditNPV				its_NPV_Type;

	public:
		// Set Cash Flows Matrix
		void	SetCreditProductDefaultMatrix(ICM_Matrix<ARM_Vector>* parameters);
		void	SetCreditProductPremiumMatrix(ICM_Matrix<ARM_Vector>* parameters);
		void	SetCreditProductPricingParametersMatrix(ICM_Matrix<ARM_Vector>* parameters);

	private:

		// Array for All default Curves
		ICM_DefaultCurve**	its_ArrayDefaultCrv;
		// Array for All shifted default Curves (hedges for different maturities)
		ICM_QMatrix<ICM_DefaultCurve*>*		its_MatrixShiftedDefaultCrv;

		bool			its_DF_Flag;			// Have the DF already been computed?
		RelativeDate	its_MaxDate;		// Last relevant date for pricing (last required DF)
		DoubleVector	its_DF;				// vector of precomputed DF (from 0 to (int) its_MaxDate)

		RelativeDate	its_MaxCreditDate;		// Last relevant Credit Observation date for pricing (Barrier computation)

		DateVector		its_SortedCreditObservationDates;
		std::vector<std::set<Tau_Item>::iterator>		its_CreditObervationDatesSortedLowsIds;
		std::vector<std::set<Tau_Item>::iterator>		its_CreditObervationDatesSortedUpsIds;

	private:

		void	Copy_MatrixShiftedDefaultCrv_From_DefaultCrv();

// BASKET

	private:

		double			TheBasketNotional;		// either CDO or CDO^2 Notional

		double			its_BasketNotional;		// CDO Notional
		double			its_TotalLoss;
		DoubleVector	its_LossesAmount;			// Vector of LossesAmount

	public:

		void	ComputeBasketNotional();
		
	private:
		
		bool	AreSpreadsHomogeneous();

// PRODUCT

	private:

		double		TheDFAtAFixedDate;

	public:

		void	CheckPremiumLegSchedule();

		void	Get_DFAtNextCreditDate(RelativeDate	TheDate, double& NextDate, double& TheDF);		// Credit Up!
		void	Get_DFAtNextPaymentDate(RelativeDate TheDate, double& NextDate, double& TheDF);

// RANDOM GENERATOR

	private:

			ICM_Root_Generator*	itsGenerator;

	protected:

		void	SetGenerator(ICM_Root_Generator * Generator) 
		{ 
			if (itsGenerator)
				delete itsGenerator;
			itsGenerator = Generator; 
		}

		ICM_Root_Generator*		GetGenerator(void) {return itsGenerator;}

		DoubleVector&	GetBetas()
		{
			if (itsGenerator)
				return itsGenerator->getBeta();
			else
				ICMTHROW(ERR_INVALID_DATA,"NULL Random Generator!");
		}

		DoubleVector&	GetComplementaryBetas()
		{
			if (itsGenerator)
				return itsGenerator->getCour();
			else
				ICMTHROW(ERR_INVALID_DATA,"NULL Random Generator!");
		}

		// to be reviewed, modify icm_root_generator.h --> generic with DoubleVector
		DoubleVector&	GetCommonFactors()
		{

			if (itsGenerator)
				return	itsGenerator->getCommonFactors();
			else
				ICMTHROW(ERR_INVALID_DATA,"NULL Random Generator!");			
		}	

	private:

		set<Tau_Item>	itsSortedDefaultTimes;				// temps de défauts ordonnés
		set<Tau_Item>	itsSortedDefaultTimes_Keep;

		vector<double>	itsDef_Prob;

		vector<double>	itsBarriers_Standard;				// vecteur des N(-1) (Fi(T))
		vector<double>	itsBarriers_Shifted;				// vecteur des N(-1) (Fi(T)) for Shfited Curves

		set<Tau_Item>	its_SortedCreditObservationDatesAndLosses;

	public:
		void	Price();
		void	PriceOrHedge();

		// SOME DATA
		void	Get_NPV(double& data)	{data = NPV;}

		void	Get_ATM_Spread(double& data)	{data = ATMSpread;}
		void	Set_ATM_Spread(const double& data)	{ATMSpread = data;}

		void	Get_ATM_PremiumLegWithoutNotio(double& data)	{data = ATMPremiumLegWithoutNotio;}

	private:
		
		void	Price_MonteCarlo(DoubleVector& Outputs);
		void	Price_Analytic_1F(DoubleVector& Outputs);

	private:
		// Inputs for Up-Front
		double		its_UpFront_RunningSpread;
		double		its_UpFront_Premium;

		// Outputs
		double		NPV;
		double		DefaultLegPV;
		double		PremiumLegPV;
		double		ATMPremiumLeg;
		double		ATMPremiumLegWithoutNotio;
		double		ATMSpread;
		double		ATMUpFront;
		double		ATMRunningSpread;

		double		its_Cash;			// completely past periods
		double		its_Accrued;		// I am in a period

		double		NPVSquare;
		double		StdError;

		double		Central_NPV;		// for Hedges
	private:
		
		void	GetMaxDFDate(RelativeDate&	MaxDate)	{MaxDate	=	its_MaxDate;}
		void	ComputeMaxDFDate();
		void	ComputeAllDF();
		
		void	ComputeMaxCreditDate();	


		void	ResetOutputs();
		void	PrepareOutputs(DoubleVector& Outputs);
		void	SetOutputData();

		void	Compute_Cash_And_Accrued();

		void	ScheduleCheckings();
		void	ComputeMaxLevels();

		// Correlation
		void	GenerateDefaultTimes_Betas();
		void	GenerateDefaultTimes_Matrix();
		
		// Compute Losses
		void	ComputeCumulativeLossesAndNbDefaults();
		void	SortAllCreditObservationDates();
		void	ComputeLossesAmountBeforeCreditWindowsDates();

		// losses
		void	GetHowMuchLossBeforeACreditObservation(int LowOrUpFlag, double& TheLoss);
		void	GetHowMuchLossBeforeADate(RelativeDate TheDate, double& TheLoss);

		// nb def
		void	GetHowManyDefaultsBeforeACreditObservation(int LowOrUpFlag, int& TheNbDef, set<Tau_Item>::iterator&	iter);
		void	GetHowManyDefaultsBeforeADate(RelativeDate TheDate, int& TheNbDef, set<Tau_Item>::iterator&	iter);
		void	GetHowManyDefaultsBeforeADate(RelativeDate TheDate, double& TheNbDef);

		// Random Generator
		void	SetRandomGenerator();
		void	ComputeBarriers(double TimeT);	// in days Time

		// Inside the loop
		void	PriceBasketForThisSimulation(DoubleVector& Outputs);
		void	PriceDefaultLegForThisSimulation_Losses(DoubleVector& Outputs);
		void	PriceDefaultLegForThisSimulation_NbDef(DoubleVector& Outputs);
		void	PricePremiumLegForThisSimulation_Losses(DoubleVector& Outputs);
		void	PricePremiumLegForThisSimulation_NbDef(DoubleVector& Outputs);

		void	Price_A_Flow_ForPremiumLegForThisSimulation_Losses(DoubleVector& Outputs);
		void	Price_A_Flow_ForPremiumLegForThisSimulation_Losses(RelativeDate TheDate, DoubleVector& Outputs);
		void	Price_A_Flow_ForPremiumLegForThisSimulation_NbDef(DoubleVector& Outputs);

	public:

		// Creation of Default Curves, and of Multi Curves Model.
		void	GenerateAllDefaultCurves();

		// Output
		void	GetDataFromLabel(string TheLabel, double& TheValue);
		void	GetDataMatrixFromLabel(string TheLabel, vector<double*>& OutputMatrix, vector<string>& OutputLabels, int& OutputNbRows, int& OutputNbCols);

// CREDIT CALIBRATOR

	public:

		void	SetCreditCalibrator_Description(ICM_Matrix<ARM_Vector>* parameters);

		void	GetCreditCalibratorChoice(CreditCalibratorSelection&	data) const	{data = its_CreditCalibratorChoice;}
		void	SetCreditCalibratorChoice(CreditCalibratorSelection	data) {its_CreditCalibratorChoice = data;}

		void	GetCreditCalibrator_NameId(int&	data) const	{data = its_CreditCalibrator_NameId;}
		void	SetCreditCalibratorChoice(int data) {its_CreditCalibrator_NameId = data;}

		void	GetCreditCalibrator_NTD(int&	data) const	{data = its_CreditCalibrator_NTD;}
		void	SetCreditCalibrator_NTD(int	data) {its_CreditCalibrator_NTD = data;}

		void	GetCreditCalibrator_Loss(double&	data) const	{data = its_CreditCalibrator_Loss;}
		void	SetCreditCalibrator_Loss(double	data) {its_CreditCalibrator_Loss = data;}

		void	GetCreditCalibrator_Density_NTD(int&	data) const	{data = its_CreditCalibrator_Density_NTD;}
		void	SetCreditCalibrator_Density_NTD(int	data) {its_CreditCalibrator_Density_NTD = data;}

		void	GetCreditCalibrator_Density_Loss_Up(double&	data) const	{data = its_CreditCalibrator_Density_Loss_Up;}
		void	SetCreditCalibrator_Density_Loss_Up(double	data) {its_CreditCalibrator_Density_Loss_Up = data;}

		void	GetCreditCalibrator_Density_Loss_Down(double&	data) const	{data = its_CreditCalibrator_Density_Loss_Down;}
		void	SetCreditCalibrator_Density_Loss_Down(double	data) {its_CreditCalibrator_Density_Loss_Down = data;}

		void	GetCreditCalibrator_Density_Loss_Step(double&	data) const	{data = its_CreditCalibrator_Density_Loss_Step;}
		void	SetCreditCalibrator_Density_Loss_Step(double	data) {its_CreditCalibrator_Density_Loss_Step = data;}

		void	GetCreditCalibrator_Expected_Loss_Down(double&	data) const	{data = its_CreditCalibrator_Expected_Loss_Down;}
		void	SetCreditCalibrator_Expected_Loss_Down(double	data) {its_CreditCalibrator_Expected_Loss_Down = data;}

		void	GetCreditCalibrator_Expected_Loss_Up(double&	data) const	{data = its_CreditCalibrator_Expected_Loss_Up;}
		void	SetCreditCalibrator_Expected_Loss_Up(double	data) {its_CreditCalibrator_Expected_Loss_Up = data;}

		void	Set_CreditCalibratorMaturitiesAsChar(int NbMat, char data[ARM_NB_TERMS][ARM_NB_MAX_CHAR_TERMS]);

		void	Get_CreditCalibrator_Lags(DoubleVector& data)	{data = its_CreditCalibrator_Lags;}
		void	Set_CreditCalibrator_Lags(const DoubleVector& data)	{its_CreditCalibrator_Lags= data;}

		void	Get_CreditCalibrator_Prob_Default(DoubleVector& data)	{data = its_CreditCalibrator_Prob_Default;}
		void	Set_CreditCalibrator_Prob_Default(const DoubleVector& data)	{its_CreditCalibrator_Prob_Default= data;}

		void	Get_CreditCalibrator_Std_Error(DoubleVector& data)	{data = its_CreditCalibrator_Std_Error;}
		void	Set_CreditCalibrator_Std_Error(const DoubleVector& data)	{its_CreditCalibrator_Std_Error= data;}

	public:

		void	Credit_Calibrate(const StringVector& Maturities);
		void	BasketCalibration(CreditCalibratorSelection TheCreditCalibratorChoice);
		void	BasketCalibrationMaturities(CreditCalibratorSelection TheCreditCalibratorChoice, DoubleVector& TheLocalMaturities, double TotalRef);
		void	BasketCalibrationDensity(CreditCalibratorSelection TheCreditCalibratorChoice, double& Maturity_YTi);

	private:

		CreditCalibratorSelection	its_CreditCalibratorChoice;
		
		int			its_CreditCalibrator_NameId;
		int			its_CreditCalibrator_NTD;
		double		its_CreditCalibrator_Loss;

		int			its_CreditCalibratorNbMaturities;				// Number of maturities
		char**		its_CreditCalibratorMaturities_AsChar;

		// for Density
		int			its_CreditCalibrator_Density_NTD;

		double		its_CreditCalibrator_Density_Loss_Down;
		double		its_CreditCalibrator_Density_Loss_Up;
		double		its_CreditCalibrator_Density_Loss_Step;
		double		its_CreditCalibrator_Expected_Loss_Down;
		double		its_CreditCalibrator_Expected_Loss_Up;

		int			size_DENSITY_LOSS;	// computed from DATA

		// the results
		DoubleVector	its_CreditCalibrator_Lags;
		DoubleVector	its_CreditCalibrator_Prob_Default;
		DoubleVector	its_CreditCalibrator_Std_Error;

		string			its_CC_Lags_String;
		string			its_CC_Prob_String;
		string			its_CC_Std_Error_String;

		int			its_Data_Matrix_NbRows;
		int			its_Data_Matrix_NbColumns;


// ------------------------------------------------------------------------------------------------
		// VARIANCE REDUCTION
// ------------------------------------------------------------------------------------------------

	private:

		void	ComputeVarianceReductionData();

// ------------------------------------------------------------------------------------------------
//	IMPORTANT SAMPLING
// ------------------------------------------------------------------------------------------------

	private:

		CreditMonteCarloVarianceReduction	its_MC_Variance_Reduction;

		// all varaibles refer to the Glasserman article
		double	its_IS_Theta;			//	Theta	
		double	its_IS_Mu;				//	Mu		Common Factor
		double	its_IS_Loss_Level;		//	x
		double	its_IS_Loss_Maturity;	//	T		time at which the Loss for Proba Adjustment will be computed

		CreditVarianceReductionIdiosyncratic	its_Theta_Choice;
		CreditVarianceReductionFactors			its_Mu_Choice;
		double	its_Target_Default_Prob;		// cf. Mark JOSHI

		
		// internal data
		double			IS_Common_exp_twists;		// exp[Psi(Theta)] = sum[k=0,.., N-1] (1 + pk(Z) * (exp(ck * Theta) - 1.0))
		DoubleVector	IS_Common_exp_twistss;
		DoubleVector	IS_individual_exp_twists;	// for each credit exp(Theta * Loss_i)
		DoubleVector	IS_individual_exp_twists_Kept;

		double	IS_Common_FactorShift;			// exp(-0.5 * its_IS_Mu * its_IS_Mu)
		double	IS_Individual_FactorShift;		// exp(-its_IS_Mu * z)

		DoubleVector	TheCond_DefProb_Vect;

	private:
	
		double	Psi_First_Deriv(double theta);
		double	Psi_Second_Deriv(double theta);


		double	its_Kept_Theta;

// ------------------------------------------------------------------------------------------------
//	HEDGES
// ------------------------------------------------------------------------------------------------

	public:
		void	Hedges(double& NPV);

	protected:

		void	ActivateShift() {its_IsActivateShift = true;}
		void	DeActivateShift() {its_IsActivateShift = false;}
		bool	IsActivateShift(void) {return its_IsActivateShift;}
		bool	IsDeActivateShift(void) {return !its_IsActivateShift;}

		// ------------------------------------------------------------
		bool	IsFirstComputationForHedgeFlag(void) {return (its_FirstComputationForHedgeFlg);}
		void	SetFirstComputationForHedgeFlag(bool value) {its_FirstComputationForHedgeFlg = value;}
		// ------------------------------------------------------------

		void	SetTenorShift(const int& nbshift) {its_TenorShift=nbshift;}
		int		GetTenorShift(void) {return its_TenorShift;}

		void	SetIssuerShift(const int& nbshift) {its_IssuerShift=nbshift;}
		int		GetIssuerShift(void) {return its_IssuerShift;}


	private:

		void	Hedges_Monte_Carlo(double& dummyNPV);
		void	Hedges_LHP(double& dummyNPV);
		void	Hedges_Recursive(double& dummyNPV);

		void	ComputeHedges();

		void	ComputeHedgeSpreadAllMaturities();
		void	ComputeHedgeSpreadParallel();
		void	ComputeHedgeDefault();
		void	ComputeHedgeRecoverySens();
		void	ComputeHedgeRecoveryLoss();
		void	ComputeHedgeRecoveryGlobal();
		void	ComputeHedgeCorrelation();

		void	HedgesFastSpreadParallel(double& NPV);
		void	HedgesFastSpreadParallel_Monte_Carlo(double& NPV);
		void	HedgesFastSpreadParallel_Recursive(double& NPV);

		void	PrepareHedges();
		void	PrepareHedgesDefault();

		bool	IsHedgesCDSToMaturity() {return HedgesCDSToMaturityFlag;}
		void	SetHedgesCDSToMaturity() {HedgesCDSToMaturityFlag = true;}
		void	UnSetHedgesCDSToMaturity() {HedgesCDSToMaturityFlag = false;}
		void	SetHedgesCDSToSpreadCurve() {HedgesCDSToMaturityFlag = false;}

		bool	IsHedgesDefault() {return its_HedgesDefault;}
		void	SetHedgesDefault() {its_HedgesDefault = true;}
		void	UnSetHedgesDefault() {its_HedgesDefault = false;}

	public:

		void	Set_CreditDataHedgesCDSMaturity(string data);

		void	Display_DefaultTimes();
		void	Display_Vector(string& label, DoubleVector&	data);

	private:

		void	ComputeBarriersShifted(double TimeT, int col_id = 0);	// in Days Time // col_id represents the hedges' scenario id

		void	GenerateDefaultTimes_Betas_ForHedge(int col_id = 0, bool FastHedgeFlag = false);
		
		void	UpdateCumulativeLossesAndNbDefaults(int Num);
		void	SetShiftedDefaultTime(int Num, double DefaultTimeT);

	// Keep Sorted Default Times
		void	Keep_SortedDefaultTimes() {itsSortedDefaultTimes_Keep	=	itsSortedDefaultTimes;};

	// ReStore Sorted Default Times
		void	Restore_SortedDefaultTimes() {itsSortedDefaultTimes	=	itsSortedDefaultTimes_Keep;};

		void	ResetAndResizeAllHedgesOutputs();

		// FAST HEDGES
		void	ComputeDirectionalShift(int col_id);
		double	ComputeBarrierDerivative(int Num, int col_id, double T);
		double	ComputeModifiedDefaultTime(int Num, double Shift);

		// Time T Loss Shifts
		void	ClearShifts() {LossTShifts.clear();}
		void	AppendShifts(double key, ICM_QMatrix<double>* data) {LossTShifts[key] = data;}
		ICM_QMatrix<double>*	GetShifts(const double& key) {return LossTShifts[key];}
		const std::map<double, ICM_QMatrix<double>*>& GetLossTShifts() const {return LossTShifts;}

	private:

		bool			its_HedgesRunning;
		int				its_CurrentHedgesIndex;
		int				its_CurrentHedgesScenario;

		int				its_temp_index;
		bool			its_HedgesDefault;

		string			its_HedgesCDSMaturity;		// the CDS which will be used in order to carry out the Hedges...
		bool			HedgesCDSToMaturityFlag;	// is it a specific CDS matching the product maturity?

		DoubleVector	its_AllNPVS;
		ICM_QMatrix<double>*	its_AllMatrixNPVS;
		DoubleVector	its_AllDefLegs;
		DoubleVector	its_AllPremLegs;

		DoubleVector	its_DefaultTimes;
		DoubleVector	its_DefaultTimesShifted;

		int				its_nb_scenarii;

		// Fast hedges
		DoubleVector	its_CommonFactors;		// for 1F, a single value
		DoubleVector	its_BarrierDerivatives_FastHedge;


		ICM_QMatrix<double>*				its_Shift_Results;
		
		map<double, ICM_QMatrix<double>*>	LossTShifts;		// Because I need them for all maturities
		int			its_CurrentTimeIndex;

		bool	its_IsActivateShift;
		bool	its_FirstComputationForHedgeFlg;

		int		its_TenorShift;
		int		its_IssuerShift;

// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------

	private:
	
		DoubleVector	its_Hedges_Delta_NPV;
		DoubleVector	its_Hedges_Hedge_Ratio;
		DoubleVector	its_Hedges_Delta_CDS;
		DoubleVector	its_Hedges_CDS_ATM_Margin;
		DoubleVector	its_Hedges_Carry;

		DoubleMatrix	its_Hedges_MatrixOutput;


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------
		// 1 FACTOR MODEL
// ------------------------------------------------------------------------------------------------

	public:
	
		void	Get_TimeStep_Prorata_1F(double&	data)	{data	=	its_Time_Step_Prorata_1F;}
		void	Set_TimeStep_Prorata_1F(const double&	data)	{its_Time_Step_Prorata_1F	=	data;}


	public:

		void	PriceBasket_1F(DoubleVector& Outputs);

		void	PriceDefaultLeg_1F_Losses(DoubleVector& Outputs);
		void	PricePremiumLeg_1F_Losses(DoubleVector& Outputs);
		void	PricePremiumLeg_1F_NbDef(DoubleVector& Outputs);
		void	PriceDefaultLeg_1F_NbDef(DoubleVector& Outputs);

		void	ComputeLossesBeforeT_1F(double T, CreditLossComputation PayOffType, double LossMin, double LossMax, double& Result);
	
		// SUB ROUTINES
	private:

		void	ComputeLossesBeforeT_FFT_1F(double T, CreditLossComputation PayOffType, double LossMin, double LossMax, double& Result);
		void	ComputeLossesBeforeT_LARGE_PORTFOLIO_1F(double T, CreditLossComputation PayOffType, double LossMin, double LossMax, double& Result);
		
		void	ComputeLossesBeforeT_LHP(double T, CreditLossComputation PayOffType, double LossMin, double LossMax, double& Result);
		void	ComputeLossesBeforeT_LHP_JPM(double T, CreditLossComputation PayOffType, double LossMin, double LossMax, double& Result);
		void	ComputeLossesBeforeT_LHP_PLUS(double T, CreditLossComputation PayOffType, double LossMin, double LossMax, double& Result);

		double	LossDigit(int NbCredits, double Strike, double MaxLoss);
		double	LossCall(int NbCredits, double Strike, double MaxLoss, double ExpectedLoss);

		void	ProbaPremiumLeg_Credit_i_1F(double T, int Typei, int NbMax, int NbMin, double LMin, double LMax, double& Result);

		void	AllocateStructures_1F();
		void	ComputeLossUnit();
		double	Compute_Probability_LossTranche(double	Loss);
		double	Compute_Expected_LossTranche(double	Loss_Min, double Loss_Max);

		double	LossLargePortfolioTranche(double mean, double variance, double LossMin, double LossMax);
		double	LossLargePortfolioTranche_Hermite(double mean, double variance, double LossMin, double LossMax);
		void	Compute_LargePortfolioHermitePolynomials();


		// HEDGES
	protected:

		inline	void SetPdefPerturb(double* pdef_perturb)
		{
			// no test
			for(int k=0; k<its_CreditsLabels.size(); k++) its_pdef_perturb[k] = pdef_perturb[k];
		}

	private:

		// 1 FACTOR MODEL
		double			its_Time_Step_Prorata_1F;
	

		int		its_Recursive_NbLossSteps;

		int		its_index_z;	// Factor Integration Step Id
		int		its_index_loss;	// Factor Integration Step Id
		int		its_ind_name;
		int		its_ind_scenario;

		double	its_factor_value;	// 1 Factor case

		DoubleVector	its_Current_DefProb;	// for index_z
		DoubleVector	its_lossdistrib; // for assessor, m_dens[k] = P(N(T)=k)
		double			its_taildistrib;
		
		// Not necessarily the optimum!
		ICM_QCubix<double>* its_ProbCond; //stockage des probas conditionnelles pour un basket de dim k, de facteur commun x et de loss l

		// HEDGES
		ICM_QCubix<double>*		its_ProbCond_Perturb; //stockage des probas conditionnelles pour un basket de dim k, de facteur commun x et de loss l
		ICM_QCubix<double>*		its_lossdistrib_perturb;
//		ICM_QMatrix<double>*	itsShifts;
		std::vector<double>		its_pdef_perturb; // vecteur de pdef perturbés
		ICM_QMatrix<double>*	its_barrier_perturb; // barrieres perturbées
		ICM_QMatrix<double>*	its_taildistrib_perturb; // for assessor, m_dens[k] = P(N(T)=k)
		
//		ICM_QMatrix<double>*	its_Shifts_Results;	-->	its_AllMatrixNPVS

		DoubleVector	its_Xi;
		DoubleVector	its_Wi;

	private:

		double	LossCallInterp(double Strike);
		double	LossDigitInterp(double Strike);

		double	LossProbabilityDistribution(double Strike);
		void	LossProbabilityDistribution(const int& lup);
		
		double	compute_cond_distribZeroLoss();
		double	compute_cond_distrib();


		// HEDGES
	
		double	Compute_Expected_LossTranche_Fast_Spread_Hedge(const double& Loss_Min, const double& Loss_Max);
		double	Compute_Expected_LossTranche_Perturb(double	Loss_Min, double Loss_Max);
		
		void	Compute_Distrib_Perturb(const int& lup);
		
		double	Compute_Cond_DistribZeroLoss_Shift_One_Name();
		double	Compute_Cond_Distrib_Shift_One_Name();

		void	Compute_Barrier_Perturb();

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// COPULA
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

	public:

		void	AllocateCopula_1F();

	private:

		ICM_Probability_Density*	its_CopulaChoice;		// I should change the label!

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// LARGE PORTFOLIO
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

	public:

	private:

		int		its_LP_Degree;		// Hermite Expansion Degree (cf. Okunev)
		DoubleVector	its_CurrentHermiteCoeffs;

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// CDO SQUARE
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
		
	public:

		void	SetCreditDataCDOSquare_Parameters(ICM_Matrix<ARM_Vector>* parameters);
		void	SetCreditDataCDOSquare_Data(ICM_Matrix<ARM_Vector>* parameters);

		int		Get_CDO_Square_Nb_Underlyings() {return its_CDO_Square_Nb_Underlyings;}

		bool	IsCDOSquare() {return (its_CDO_Type == CPT_CDO_SQUARE);}
		bool	IsCDOStandard() {return (its_CDO_Type == CPT_STD_CDO);}

	private:

		int		its_CDO_Square_Nb_Underlyings;		// from Excel
		int		its_NbRelevant_CDO_Underlyings;

		double	itsCDOSquareNotional;

		CreditProductType		its_CDO_Type;

		ICM_QMatrix<int>*		its_CDO_Square_Credit_Ids;
		ICM_QMatrix<double>*	its_CDO_Square_Credit_Losses;
		ICM_QMatrix<double>*	its_CDO_Square_Credit_Notionals;

		IntVector				its_CDO_Square_CDO_Includes;
		DoubleVector			its_CDO_Square_CDO_Maturities;
		IntVector				its_CDO_Square_CDO_NbCredits;
		DoubleVector			its_CDO_Square_CDO_Attachments;
		DoubleVector			its_CDO_Square_CDO_Detachments;
		DoubleVector			its_CDO_Square_CDO_Notionals;

		// -----------------------------------------------------
		// The Useful and Internal Ones
		// -----------------------------------------------------
		IntVector		its_CDO_Square_Relevant_CDO_Ids;
		DoubleVector	its_CDO_Square_Relevant_CDO_MaturitiesInYearFraction;
		IntVector		its_CDO_Square_Relevant_CDO_NbCredits;
		DoubleVector	its_CDO_Square_Relevant_CDO_Attachments_Pct;
		DoubleVector	its_CDO_Square_Relevant_CDO_Detachments_Pct;
		
		DoubleVector	its_CDO_Square_Relevant_CDO_Notionals;		// takes into account rescaling Notionals, if any
		DoubleVector	its_CDO_Square_Relevant_CDO_Attachments_Notio;
		DoubleVector	its_CDO_Square_Relevant_CDO_Detachments_Notio;
		DoubleVector	its_CDO_Square_Relevant_CDO_Rescaling_Factor;

		ICM_QMatrix<int>*		its_CDO_Square_Relevant_Credit_Ids;
		ICM_QMatrix<bool>*		its_CDO_Square_Relevant_Credit_Includes;
		ICM_QMatrix<double>*	its_CDO_Square_Relevant_Credit_Losses;


	private:

		void	PrepareCDOSquareData();

		void	ComputeCumulativeLossesAndNbDefaults_CDO_SQUARE();
		// to do UPDATE
		void	ComputeLossesAmountBeforeCreditWindowsDates_CDO_SQUARE();
		
		void	GetHowMuchLossBeforeACreditObservation_CDO_SQUARE(int LowOrUpFlag, double& TheLoss);
		void	GetHowMuchLossBeforeADate_CDO_SQUARE(RelativeDate TheDate, double& TheLoss);
		void	GetHowManyDefaultsBeforeACreditObservation_CDO_SQUARE(int LowOrUpFlag, int& TheNbDef, set<Tau_Item>::iterator&	iter);
		void	GetHowManyDefaultsBeforeADate_CDO_SQUARE(RelativeDate TheDate, int& TheNbDef, set<Tau_Item>::iterator&	iter);

		// USELESS ?
		void	GetHowMuchLossBeforeACreditObservation_CDO_SQUARE(int LowOrUpFlag, DoubleVector& TheLosses);
		void	GetHowMuchLossBeforeADate_CDO_SQUARE(RelativeDate TheDate, DoubleVector& TheLosses);
		void	GetHowManyDefaultsBeforeACreditObservation_CDO_SQUARE(int LowOrUpFlag, IntVector& TheNbDefs, set<Tau_Item>::iterator&	iter);
		void	GetHowManyDefaultsBeforeADate_CDO_SQUARE(RelativeDate TheDate, IntVector& TheNbDefs, set<Tau_Item>::iterator&	iter);

//		void	PriceDefaultLegForThisSimulation_Losses_CDO_SQUARE(DoubleVector& Outputs);
//		void	PriceDefaultLegForThisSimulation_NbDef_CDO_SQUARE(DoubleVector& Outputs);
//		void	PricePremiumLegForThisSimulation_Losses_CDO_SQUARE(DoubleVector& Outputs);
//		void	PricePremiumLegForThisSimulation_NbDef_CDO_SQUARE(DoubleVector& Outputs);

		// MISCELLEANOUS
		void	DisplayCDOSquareData();


// OUTPUTS
	private:

		FILE	*its_fOut;

		DoubleVector	tmpPrem;

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// 1 FACTOR NIG COPULA
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

	public:

		double	Get_NIG_Alpha(void) {return its_NIG_Alpha;}
		void	Set_NIG_Alpha(double& data)	{its_NIG_Alpha= data;}

		double	Get_NIG_Beta(void) {return its_NIG_Beta;}
		void	Set_NIG_Beta(double& data)	{its_NIG_Beta= data;}

		double	Get_NIG_Mu(void) {return its_NIG_Mu;}
		void	Set_NIG_Mu(double& data)	{its_NIG_Mu= data;}

		double	Get_NIG_Delta(void) {return its_NIG_Delta;}
		void	Set_NIG_Delta(double& data)	{its_NIG_Delta= data;}

		double	Get_NIG_Rho(void) {return its_NIG_Rho;}
		void	Set_NIG_Rho(double& data)	{its_NIG_Rho= data;}

	private:

		double	its_NIG_Alpha;
		double	its_NIG_Beta;
		double	its_NIG_Mu;
		double	its_NIG_Delta;
		double	its_NIG_Rho;

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// 1 FACTOR STOCHASTIC CORRELATION
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

		// BERNOULLI

	public:

		double	Get_SC_Rho1(void) {return its_SC_Rho1;}
		void	Set_SC_Rho1(double& data)	{its_SC_Rho1= data;}

		double	Get_SC_Rho2(void) {return its_SC_Rho2;}
		void	Set_SC_Rho2(double& data)	{its_SC_Rho2= data;}

		double	Get_SC_Prob(void) {return its_SC_Prob;}
		void	Set_SC_Prob(double& data)	{its_SC_Prob= data;}

	private:

		double	its_SC_Rho1;
		double	its_SC_Rho2;
		double	its_SC_Prob;

		// ----------------------------------------------------
		// for internal use
		// ----------------------------------------------------

	private:

		// STOCHASTIC CORRELATION ALLOCATIONS and INITIALISATIONS
		void	Allocation_Stochastic_Correlation_Data();

	private:

		int			its_SC_NbFactors;

		DoubleVector	its_Used_Beta_SC_Vector;
		DoubleVector	its_Used_SQRT_OneMinusBetaSquare_SC_Vector;

		DoubleVector	its_SC_Coefficients;

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// CALIBRATION
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

	public:

		ICM_Credit_Manager_Calibrator	*its_Correlation_Calibrator;

	public:

		void	Set_CorrelationCalibrator(ICM_Matrix<ARM_Vector>* Matrix_Description, ICM_Matrix<ARM_Vector>* Matrix_Parameters, vector<ICM_Mez*>& Vector_Mezz);
		void	Correlation_Calibrate();

	public:

		void	Price_CreditProduct(ICM_Mez* Current_Product, CreditManager_Model The_Pricing_And_Copula_Choice, DoubleVector& TheParameters, DoubleVector& TheCorrelationParameters, DoubleVector& TheProductParameters);

	private:

		void	Fill_CreditDataParameters();
		void	Fill_CreditDataDescription();
		void	Fill_CreditModelParameters();
		void	Fill_CreditCorrelationParameters();
		void	Fill_CreditProductDefault();
		void	Fill_CreditProductPemium();
		void	Fill_CreditProductPricingParameters();
		void	Fill_CreditManagerInternalData();

		void	Fill_DataFrom_ModelMultiCurves(ARM_Security *option, ARM_Model *mod);

		void	Update_CreditDataParameters();
		void	Update_CreditDataDescription();
		void	Update_CreditModelParameters(CreditManager_Model The_Pricing_And_Copula_Choice, DoubleVector& TheParameters);
		void	Update_CreditCorrelationParameters(DoubleVector& TheCorrelationParameters);
		void	Update_CreditProductDefault(ICM_Mez* Current_Product);
		void	Update_CreditProductPremium(ICM_Mez* Current_Product);
		void	Update_CreditProductPricingParameters(ICM_Mez* Current_Product, DoubleVector& TheProductParameters);

		void	SetICMOutputsFromCreditManager();


	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// ARM COMPLIANCE
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

	public:

		// double	ComputeSensitivity(const qSENSITIVITY_TYPE& typesensi, 
		// 							  const * plot, 
		// 							  char* label = NULL, 
		// 							  const double& epsilon = CREDIT_DEFAULT_VALUE);
	
	private:

		void	GetDataFromCreditProduct();
		void	GetDataFromCreditMultiCurves();

		int		Get_LabelId(const std::string&data);

		bool	AreHedgesToCompute() {return its_Hedges_To_Compute;}
		void	SetHedges_Computed() {its_Hedges_To_Compute = false;}
		void	SetHedges_ToCompute() {its_Hedges_To_Compute = true;}

	private:

		ICM_Customized_CDO*						its_Credit_Product;
		ICM_Customized_Credit_MultiCurves*		its_Credit_Market_Data;

		bool	its_Hedges_To_Compute;

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// SOME TOOLS
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

		CreditManager_Map_Loss	its_Loss_Distrib_Map;

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// DISPLAY OUTPUT
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------

	private:

		bool		its_Display_DefaultTimes_Flag;
		bool		its_Display_LossesAmount_Before_CreditDates_Flag;
		bool		its_Display_Sorted_DefaultTimes_Flag;
		bool		its_Display_CumulativeLossesAndDefaults_Flag;

	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	// TESTING PURPOSES
	// ----------------------------------------------------------------------------------------------
	// ----------------------------------------------------------------------------------------------
	
	public:
// 17783		void	Test_Integration_Dim();


	public:
		int		its_Algo_Type;

	protected:
	double ComputeSensitivity(const qSENSITIVITY_TYPE& typesensi, 
		const std::string& plot,
		const std::string& label,
		double epsilon,  double epsilonGamma = 0) ; 

};



#endif /*---- End of file ----*/
