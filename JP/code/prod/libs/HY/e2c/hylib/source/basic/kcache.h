// KCache.h: interface for the KCache class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DRCACHE_H__D4BA5D0F_3D2F_11D2_97D3_00C04FD8EB9A__INCLUDED_)
#define AFX_DRCACHE_H__D4BA5D0F_3D2F_11D2_97D3_00C04FD8EB9A__INCLUDED_

/**@#-*/
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
/**@#+*/

#include "kstring.h"
#include <list>
#include <map>




/** Interface for cache item class.

  @see KCacheItemPtr
  @see KCache
  @see KCacheInput
*/
class KCacheItem 
{
public:
	/**@#-*/
	virtual ~KCacheItem(){} //
	/**@#+*/
	/** Returns the number of bytes an item occupies */
	virtual int bytes() = 0;	// Tells how big the item is
};

/** Interface for cache item ptr.

  Performs reference counting on pointers to cache items.  We need to know which items in the cache
  are currently being referenced (to ensure they are not deleted).  Thus, we need to reference count the pointers
  to cache items.

  Be sure to examine the usage in KCache.  Due to language (developer) deficiencies (stupidity), there are usage
  requirements.

  @see KCacheItem
  @see KCache
  @see KCacheInput
*/
class KCacheItemPtr
{
public:
	KCacheItemPtr () : m_ptr(NULL) {} //
	KCacheItemPtr (KCacheItem*); //
	KCacheItemPtr (const KCacheItemPtr&); //

	KCacheItemPtr& operator=(const KCacheItemPtr&); //
	KCacheItem* c_ptr() {return m_ptr;} // Returns the c-pointer for upward casting

	~KCacheItemPtr(); //
protected:
	KCacheItem* m_ptr;
};

/** Interface for cache input class.

  @see KCacheItemPtr
  @see KCacheItem
  @see KCache
*/
class KCacheInput 
{
public:
	/** Unique KString describing the type of input */
	KCacheInput (KString type) : m_type (type) {} // String description of type
	/**@#-*/
	virtual ~KCacheInput(){} //
	/**@#+*/

	/** Return the type of input */
	KString type() {return m_type;} // Returns the type

	/**@#-*/
	friend std::ostream& operator<< (std::ostream& s, const KCacheInput& a)
	{a.print(s); return s;} //
	/**@#+*/
protected:
	bool good (KCacheInput& a); // Checks whether the input in a is suitable for
	// the input in *this
	friend class KCache;
	virtual KCacheItem* create () = 0;
	virtual KCacheInput* copy () =0;
	virtual void print(std::ostream& s) const = 0;
	virtual bool ok_to_use (KCacheInput&) = 0;
	KString m_type;
};

/** Main cache class.

	The classes KCache, KCacheInput, KCacheItem, and KCacheItemPtr support the cache.

	In order to cache soemthing, you need to divide into two parts:

  <ol>
	<li> A (short) input description that describes how the create the item.  This input must inherit
	KCacheInput and implement the four virtual functions.  In particular, you must
	<ol>
	<li> Give a unique name to input and pass into the constructor of KCacheInput.

  <li> Implement <pre>KCacheItem* create </pre> which creates an item from the input.

  <li> Implement <pre>KCacheInput* copy</pre> which copies the input.

  <li> Implement <pre>void print(ostream&amp) const</pre> which prints the input.

  <li> Implement <pre>bool ok_to_use (KCacheInput&amp)</pre> which tests whether the argument is the same or more
	general version of the input (ie it's ok the use the item generated by the argument input, instead of the
	item generated by the current input).
	</ol>

  <li> Create in item, which is created from an input.  This item must inhert KCacheItem and implement the
	virtual function <pre> int bytes() const </pre> which returns the number of bytes the item occupies.

  <li>  To use the cache,
	<pre> <dir>
	@@ Input input; // Input inherits from KCacheInput
	@@ KCacheItemPtr a = theCache.get(input);	// Gets the corresponding item from theCache.  If it doesn't exist, it will be created.
	@@ Item* b = (Item*) a.c_ptr(); // Item inherits form KCacheItem.  Now, use b like a normal Item*
  </dir></pre>
	To properly maintain the count,
			you must keep <b>a</b> and <b>b</b> in the same scope.  Usually, <b>a</b> and <b>b</b> are both
			part of the same class, so this is automatic.
		
			Note: this syntax and usage is regrettable, but I'm to stupid to do anything more intelligent.
  </ol>

  The cache is stored in global variable called:		theCache, which does the following:

<ol> <li>  For a given input, it checks whether any cached input satisfies any existing
			input.  For example, an input that describe a tree that is a subtree 
			of a cached tree can simply use the cached tree.

			<ol><li>	If it finds a suitable cached item, it will return this item.

			<li>	Otherwise, it will create a new item and put it in cache along with
				the input description.
				</ol>

		<li>	Maintains a count of how much memory is the cache.  It only keeps track
			of the item size, since the input is assumed to be small.
			If we exceed a designated capacity, we will clean the cache of all
			UNREFERENCED items.  Any non-malicous code will be safe from dangling
			references.
</ol>
  @see KCacheItemPtr
  @see KCacheItem
  @see KCache
  @see KCacheInput
*/
class KCache  
{
public:
	KCache(int capacity = 0); //
	~KCache(); //
	void setCapacity(int capacity); //

	KCacheItemPtr get (KCacheInput&); // Gets a KCacheItemPtr that satisfies the input
	void clean (); // Cleans any unreferenced memory

	int size(); // Returns current size
	int capacity(); // Returns current capacity

	friend std::ostream& operator<< (std::ostream&, const KCache&); //
protected:
	friend KCacheItemPtr;

	struct CacheElem {
		CacheElem (KCacheInput* input, KCacheItem* item) 	 
			: m_item(item), m_input(input), m_count(0) {}
		KCacheItem* m_item;
		KCacheInput* m_input;
		int m_count;
		bool operator==(const CacheElem& a) const
		{return (m_item == a.m_item && m_input == a.m_input);}
	};

	typedef KMap (KCacheItem*, CacheElem*) ItemElemMap;
	typedef KList (CacheElem) ElemList;
	typedef KMap (KString, ElemList) TypeElemMap;

	TypeElemMap m_elemMap;
	ItemElemMap m_itemMap;
	int m_capacity;
	int m_size;

	KCacheItemPtr add (KCacheInput&);

	KCacheItemPtr use (CacheElem&);

	void checkCapacity();

	void increaseCount (KCacheItem* item) 
	{
		(m_itemMap[item]->m_count)++;
	}

	void decreaseCount (KCacheItem* item) 
	{
		(m_itemMap[item]->m_count)--;
	}
};

/** Global cache variable */
extern KCache theCache; //v Global cache

inline
KCacheItemPtr::KCacheItemPtr (KCacheItem* p):m_ptr(p) 
{if (p) theCache.increaseCount(p);}

inline
KCacheItemPtr::KCacheItemPtr (const KCacheItemPtr& a)
{
	m_ptr = a.m_ptr;
	if (m_ptr) theCache.increaseCount(m_ptr);
}

inline
KCacheItemPtr& KCacheItemPtr::operator=(const KCacheItemPtr& a)
{
	m_ptr = a.m_ptr;
	if (m_ptr) theCache.increaseCount(m_ptr);
	return *this;
}

inline
KCacheItemPtr::~KCacheItemPtr()
{
	if (m_ptr)
		theCache.decreaseCount(m_ptr);
}



#endif // !defined(AFX_DRCACHE_H__D4BA5D0F_3D2F_11D2_97D3_00C04FD8EB9A__INCLUDED_)
