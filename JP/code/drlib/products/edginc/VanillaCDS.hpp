//----------------------------------------------------------------------------
//
//   Group       : Quatitative Research
//
//   Filename    : VanillaCDS.hpp
//
//   Description : A standard implmentation of a CDS (credit default swap)
//                 to buy/sell protection.  A VanillaCDS will have both a
//                 fee leg and a protection leg.
//                 Position(+) notional = Long Risk (i.e. receive fee).
//
//                 The actual work horse on the integration of the legs is
//                 done by the IDiscountCurveRisky as it knows all the
//                 relevant survival probabilities and discount curve.
//
//   Author      : Doris Morris
//
//   Date        : February 2006
//
//----------------------------------------------------------------------------

#ifndef QLIB_VANILLACDS_HPP
#define QLIB_VANILLACDS_HPP

#include "edginc/FORWARD_DECLARE.hpp"
#include "edginc/FORWARD_DECLARE_WRAPPER.hpp"
#include "edginc/Instrument.hpp"
#include "edginc/LastSensDate.hpp"
#include "edginc/ClosedFormCDSPS.hpp"
#include "edginc/Theta.hpp"
#include "edginc/ICDS.hpp"
#include "edginc/InstrumentSettlement.hpp"
#include "edginc/Stub.hpp"
#include "edginc/VanillaCreditFeeLeg.hpp"
#include "edginc/VanillaCreditContingentLeg.hpp"

DRLIB_BEGIN_NAMESPACE

/* Forward declare the classes refered to from this file if we are not
 * interested in their storage properties (ie, they are used through (smart)
 * pointers and therefore their include files are not required here - they
 * will be in the source files though)*/
FORWARD_DECLARE(Settlement);
FORWARD_DECLARE(BadDayConvention);
FORWARD_DECLARE(DayCountConvention);
FORWARD_DECLARE(IForwardRatePricer);
FORWARD_DECLARE_WRAPPER(YieldCurve);
FORWARD_DECLARE_WRAPPER(ICDSParSpreads)
FORWARD_DECLARE_WRAPPER(IDiscountCurveRisky);
FORWARD_DECLARE_WRAPPER(IRiskyContingentLeg);


/** A VanillaCDS is a finite credit instrument made up of the
 *  following components: an IRiskyFeeLeg and an IRiskyContingentLeg that are of
 *  type ICreditVanillaInstrument.
 *
 *  A VanillaCDS can be created by a given set of parameters (limited or full)
 *  The flows for both legs are generated by its' convention.
 *  For e.g. a VanillaCreditFeeLeg implements an IRiskyFeeLegConvention.
 *  Within VanillaCreditFeeLeg, the leg can be created or re-created given
 *  a start date, end date and a fee rate.
 *
 */
class PRODUCTS_DLL VanillaCDS: public CInstrument,
                  public virtual ICDS,
                  public virtual ICDSConvention,
                  virtual public IBadDayAdjuster,
                  public virtual LastSensDate,
                  public virtual ClosedFormCDSPS::IIntoProduct,
                  public virtual Theta::Shift
{

public:

    //-------------------
    // VanillaCDS methods
    //-------------------
  static CClassConstSP const TYPE;

  virtual ~VanillaCDS();
  
  /** Constructor*/
	     
  VanillaCDS(DateTime valueDate,
	     DateTime effectiveDate,          //protection start date 
	     DateTime maturityDate,           //maturity date i.e. protection end date 
	     bool koBeforeIssueDate,          //knock out cds if the underlying credit defaults before issue date. 
	     YieldCurveWrapper discount,      //discount curve 
	     ICDSParSpreadsWrapper riskyCurve,//risky curve 
	     bool payAccruedFee,              //pay accrued fee on default or not 
	     double feeRate,                  //fee 
	     MaturityPeriodSP paymentFreq,    //payment frequency 
	     DayCountConventionSP pmtDcc,     //payment day count convention 
	     DayCountConventionSP accrualDcc, //accrual day count convention 
	     BadDayConventionSP pmtBdc,       //payment bad day convention 
	     BadDayConventionSP accrualBdc,   //accrual bad day convention 
	     BadDayConventionSP valuationBdc, //valuation bad day convention 
	     HolidayWrapper pmtHol,           //payment holiday(s) 
	     HolidayWrapper accrualHol,       //accrual holiday(s) 
	     string frontStubType,            //sf (short front stub), lf(long front stub) 
	     double recoveryRate,             //recovery rate 
	     double delay,                    //delay between default date and settlement upon default 
	     SettlementSP settlementOffset);  //offset from a given trade date for settlement
  
    /** Price the instrument
     *  Price (dirty) = - IRiskyFeeLeg.getFeeLegPV(DateTime valuationDate, IDiscountCurveRisky)
	                + IRiskyContingentLeg.getContingentLegPV(DateTime valuationDate, IDiscountCurveRisky)
                        since positive notional = long protection
     *  The notional for each fee interval can be varying.
     *  However varying notional has yet to be implemented.
     *  The Vanilla CDS will retrieve its appropriate IDiscountCurve risky
     *  The price of the instrument is stored in CResults to fit into the QLib framework.
     */
    void price(CResults*            results,
	           Control*             control,
               IForwardRatePricerSP model) const;

    //--------------------
    // CInstrument methods
    //--------------------

    /**
     * Called immediately after object constructed
     */
    virtual void validatePop2Object();

    /** Allow the instrument to retrieve its market data */
    virtual void GetMarket(const IModel*            model,
	                       const CMarketDataSP      market);

    /** called after market data has been retrieved */
    virtual void Validate();

    /** Returns the value date (aka today) the instrument is currently pricing for */
    virtual DateTime getValueDate() const;

    /** Returns the name of the instrument's discount currency */
    virtual string discountYieldCurveName() const;

    //-------------
    // ICDS methods
    //-------------

    /** Return the fee leg */
    virtual ICreditFeeLegSP getFeeLeg() const;

    /** Return the contingent leg */
    virtual ICreditContingentLegSP getContingentLeg() const;

    /**
     * Compute PV of contingent leg at valuation date, with instrument default
     * settlement and payment date behaviour.
     */
     virtual double getContingentLegPV(const DateTime&              valuationDate,
                                       const IDiscountCurveRisky&   crv) const;

     /**
      * Compute PV of contingent leg at valuationDate, but for unconditional payment
      * at paymentDate, conditional on no new defaults before valuationDate.
      */
     virtual double getContingentLegPV(const DateTime&              valuationDate,
                                       const DateTime&              paymentDate,
                                       const IDiscountCurveRisky&   crv) const;

    /** Return Accrued Interest (cash amount, not percentage) for settlement on settlementDate */
    virtual double getAccruedInterest(const DateTime&  settlementDate,
                                      IForwardRatePricerSP model) const;

    /**
     * Returns the present value of a vanilla credit instrument at valuationDate,
     * conditional on default at defaultDate.
     */
    virtual double getPVGivenDefault(const DateTime&            valuationDate,
                                     const DateTime&            defaultDate,
				                     const IDiscountCurveRisky& crv,
                                     IForwardRatePricerSP       model) const;
    /**
     * Determines if a vanilla cds is perpetual.
     */
    virtual bool hasFiniteMaturity() const;

    /**
     * Returns the maturity of a vanilla cds.
     */
    virtual DateTime getMaturity() const;

    /**
     * Returns the earliest of the first accrual period, start of the contingent leg,
     * the first cash flow, etc.
     */
    virtual DateTime getStartDate() const;

    /**
     * Get the base (initial) notional of the vanilla credit instrument.
     * Positive notional = long risk/short protection.
     * If the notional is varying, this will return the base notional.
     */
    virtual double getNotional() const;

    /**
     * Set the base (initial) notional of the vanilla credit instrument.
     * Positive notional = short risk/long protection.
     */
    virtual void setNotional(double newNotional);

    /** Returns the day count convention used for accruals */
    virtual DayCountConventionSP getAccrualDcc() const;

    virtual CashFlowArraySP getInstrumentCashFlows(IForwardRatePricerSP model) const;

    /** Returns the wrapper to the yield curve */
    virtual YieldCurveWrapper getYieldCurveWrapper() const;

    /** Returns the wrapper describing the credit curve */
    virtual ICDSParSpreadsWrapper getParSpreadsWrapper() const;

    /**
     *  Compute the PV of a vanilla cds with the given legs given no default before
     *  valuation date.
     *  Overrides ICDS implementation
     */
    virtual double getPV(const DateTime&              valuationDate,
                         const IDiscountCurveRisky&   crv,
                         const IDecretionCurveConstSP prepay,
                         IForwardRatePricerSP         model,
                         IBadDayAdjusterConstSP       bda) const;


    /**
     * Compute the PV of a vanilla cds at valuationDate for unconditional settlement and
     * payment on paymentDate.  Conditional on no new defaults before valuationDate if
     * valuationDate is in the future.
     * Overrides ICDS implementation
     */
    virtual double getPV(const DateTime&              valuationDate,
                         const DateTime&              settlementDate,
                         const IDiscountCurveRisky&   crv,
                         const IDecretionCurveConstSP prepay,
                         IForwardRatePricerSP         model,
                         IBadDayAdjusterConstSP       bda) const;


    //-----------------------
    // ICDSConvention methods
    //-----------------------

    virtual ICDSSP generateCDS(const DateTime&              startDate,
                               const DateTime&              endDate,
                               double                       feeRate) const;

    //-------------------------
    //  IBadDayAdjuster methods
    //-------------------------

    /** Returns "date" bad day adjusted using the bad day convention
     * and holidays in this object */
    virtual DateTime badDayAdjust(const DateTime& date) const;

    /** Add a number of business days to a date */
    virtual DateTime addBusinessDays(const DateTime& from, int busDays) const;

    //---------------------
    // LastSensDate methods
    //---------------------

    /** When to stop tweaking for LastSensDate */
     virtual DateTime endDate(const Sensitivity* sensControl) const;

    //--------------------------------------
    // ClosedFormCDSPS::IIntoProduct methods
    //--------------------------------------

    virtual ClosedFormCDSPS::IProduct* createProduct(ClosedFormCDSPS* model) const;

    //---------------------
    // Theta::Shift methods
    //---------------------

    virtual bool sensShift(Theta* shift);




    ///***************************** Fee Leg**********************************/
    ///**
    // * Returns the fee rate on the IRiskyFeeLeg.
    // */
    // virtual double getRate() const;

    // /**
    //  * Change the fee rate on the fee leg.
    //  */
    // virtual void setRate(double                      newRate);

    // /**
    //  * Compute PV of fee leg at valuation date, with instrument default settlement
    //  * and payment date behaviour.
    //  */
    // virtual double getFeeLegPV(const DateTime&              valuationDate,
    //                            const IDiscountCurveRisky&   crv) const;

    ///**
    // * Compute PV of fee leg at valuationDate, but for unconditional payment at
    // * paymentDate, conditional on no new defaults before valuationDate.
    // */
    // virtual double getFeeLegPV(const DateTime&              valuationDate,
    //                            const DateTime&              paymentDate,
    //                            const IDiscountCurveRisky&   crv) const;

    // virtual double getFeeLegPV(const DateTime&                valuationDate, 
    //                            const DateTime&                paymentDate, 
    //                            const IDiscountCurveRisky&     crv,
    //                            bool                           defaultValueOnly) const;





protected:
    string                 name;

private:
    // Deals with the output requests
    void addOutputRequests(Control* control,
                           Results* results,
                           const IDecretionCurveConstSP prepay,
                           IForwardRatePricerSP model) const;

    /** when do payments occur ? */
    DateTimeArraySP paymentDates() const;

    // For reflection
    VanillaCDS();
    static void load(CClassSP& clazz);
    static IObject* defaultConstructor();


    // Fields
    /* Positive notional = long protection */
    mutable double         baseNotional;         // initial notional
    DateTime               valueDate;            // Valuation date
    DateTime               effectiveDate;        // Protection start date
    DateTime               maturityDate;         // Protection end date
    bool                   koBeforeIssueDate;    // Will the CDS knock out if the underlying credit defaults
                                                 // before the issue date.  If false, the CDS will not know out if default
                                                 // but pay on the issue date.

    // to populate
    YieldCurveWrapper      discount;
    //IDiscountCurveRiskyWrapper   riskyCurve;
    ICDSParSpreadsWrapper  riskyCurve;

    bool                   payAccruedFee;        // Whether to pay accrued fee on default or not
	                                             // Accrual dcc and bdc is delegated to the fee leg
    // fee leg inputs
    mutable double         feeRate;               // fix fee/spread or the current floating fix fee 
    MaturityPeriodSP       paymentFreq;           // payment frequency
    DateTime               fcd;                   // first coupon date
    DateTime               lcd;                   // last coupon date


    // Convention
    DayCountConventionSP   pmtDcc;                // Payment day count convention
    DayCountConventionSP   accrualDcc;            // Accrual day count convention

    BadDayConventionSP     pmtBdc;                // Payment Bad Day Convention
    BadDayConventionSP     accrualBdc;            // Accrual Bad Day convention
    BadDayConventionSP     valuationBdc;          // Valuation Bad Day Convention

    HolidayWrapper         pmtHol;                // Payment holiday
    HolidayWrapper         accrualHol;            // Accrual holiday

    // Stub convention
    string                 frontStubType;         // e.g. sf (short front), lf (long front) 

    string                 backStubType;          // e.g. sb (short back), lb (long back)

    // Protection Leg
    /* payAccruedFee = true, recovery type = 1 */
    /* payAccruedFee = false, recovery type = 0 */
    string                 recoveryTypeString;     // Recovery type 1-R
    mutable double         recoveryRate;

    double                 delay;                  // payment offset
    SettlementSP           settlementOffset;       // valuation offset (e.g. T+3)
    InstrumentSettlementSP settlementType;         // physical or cash? Instrument Settlement 


    /* Internally constructed via the input fields */
    mutable VanillaCreditFeeLegSP        feeLeg;                // annuity leg
    mutable VanillaCreditContingentLegSP contingentLeg;         // protection leg
    IDiscountCurveRisky::RecoveryType    recovery;              // recoveryType -> recovery            

    /* To add to the interface*/
    StubSP stubPaymentType;

};

typedef smartPtr<VanillaCDS>      VanillaCDSSP;
typedef smartConstPtr<VanillaCDS> VanillaCDSConstSP;
typedef MarketWrapper<VanillaCDS> VanillaCDSWrapper;

DRLIB_END_NAMESPACE

#endif
