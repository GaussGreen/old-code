#ifndef _KCOMPONENT_HPP
#define _KCOMPONENT_HPP

#include "edginc/FDModel.hpp"
#include "edginc/Instrument.hpp"

DRLIB_BEGIN_NAMESPACE

class KComponent;
typedef smartPtr<KComponent> KComponentSP;
typedef smartConstPtr<KComponent> KComponentConstSP;

class IRPRODUCTS_DLL KComponent: public CInstrument,
                  virtual public IProdCreator,
                  virtual public KnownCashflows::IEventHandler,
                  virtual public AllCashflows::IEventHandler,
                  virtual public LastSensDate
{
public:
    static CClassConstSP const TYPE;

    /******************/
    FORWARD_DECLARE(CashflowNode);
    class IRPRODUCTS_DLL CashflowNode : public CObject {
    public:
        static CClassConstSP const TYPE;

        KComponentConstSP   comp;
        CashflowInfoArraySP cashflows; // cashflows generated by comp
        CashflowNodeArray   underlyings; // cashflows generated by the underlyings of comp

        void setMultiplier(double multiplier);
        CashflowNode() : CObject(TYPE), cashflows(new CashflowInfoArray) {}

    private:
        static void load(CClassSP& clazz);
        static IObject* defaultConstructor(void) { return new CashflowNode(); }
    };
    /******************/

    /************* exported fields ***********/
public: // can be modified by shell instruments
    YieldCurveWrapper discount;
    string outputName;
    bool recordOutputName;

    /************* transient fields ***********/
public:
    bool undIsPhysical; // skip underlying non-pricing events. Set by the component in setup().
    bool isPhysical; // computed from undIsPhysical after setup()

protected:
    bool setupCalled;

private:
    bool marketRetrieved; // avoids retrieving market twice
    bool topComponent;
    YieldCurveWrapper modelDomesticYC;
    DateTime today;

    /***************** methods ***************/
public:
    /* **/
    /* *******/
    /* ************ [begin] exposed functions */
    virtual const YieldCurveWrapper& discountYieldCurveWrapper() const { return discount; }
    bool isTopComponent() const {return topComponent;}
    DateTime getLastInstrDate() const;
    void recordExtraOutput(Control* ctrl, Results* results) const; // records addational output information
    void getCfDates(DateTimeArray &cfDates) const; // Get cashflow Dates
    YieldCurveConstSP getModelDomesticYC() const {return modelDomesticYC.getSP();}
    YieldCurveConstSP getActualDiscount() const;
    DateTime getToday() const {return today;}
    /* ************ [end] exposed functions */
    /* *******/
    /* **/

    /* **/
    /* *******/
    /* ************ [begin] methods that should not need overloading (final) */
    /* CInstrument:: */
    virtual void Validate(void) {}
    virtual void GetMarket(const IModel *model, const CMarketDataSP market);
    virtual DateTime getValueDate() const;
    virtual string discountYieldCurveName() const;
    virtual bool priceDeadInstrument(CControl* control, CResults* results) const;
    /* KnownCashflows::IEventHandler:: */
    virtual void getEvents(const KnownCashflows*, IModel* model,const DateTime& eDate, EventResults* events ) const;
    /* AllCashflows::IEventHandler:: */
    virtual void getEvents(const AllCashflows*, IModel* model,const DateTime& eDate, EventResults* events ) const;
    /* LastSensDate:: */
    virtual DateTime endDate(const Sensitivity* sensControl) const;
    /* ************ [end] CInstrument:: methods that should not need overloading (final) */
    /* *******/
    /* **/

    /* **/
    /* *******/
    /* ************ [begin] functions to override */

    // Setup the component. 
    // The derived function must also call KComponent::setup() and the setup() of its underlyings
    virtual void setup(const IModel* model, const MarketData* market); 

    // Experimental for now
    virtual void getAccEndDates(DateTimeArray &accEndDates) const {}

    virtual DateTime getLastDate(void) const {return DateTime();}

    // Must be overriden to report known cash flows if the component generate any.
    virtual void reportCashFlows(CashflowInfoArray &cashflowInfos, bool amountsNeeded ) const {}
    virtual CashflowNodeSP reportCashflowsTree(bool amountsNeeded) const;
    /* ************ [end] functions to override */
    /* *******/
    /* **/
    
protected:
    /** convenience function to re-throw an exception adding 
      * the component type and name to the message stack */
    ModelException makeException(exception &e, const string &functionName) const;

    KComponent(CClassConstSP const &type) : 
        CInstrument(type), recordOutputName(true), 
        undIsPhysical(true), isPhysical(true), setupCalled(false), marketRetrieved(false), 
        topComponent(false) {}
    KComponent(const string &discount, const string &outputName, CClassConstSP const &type) :
        CInstrument(type), discount(discount), outputName(outputName), recordOutputName(true),
        undIsPhysical(true), isPhysical(true), 
        setupCalled(false), marketRetrieved(false), topComponent(false) {}

    static void load(CClassSP& clazz);
};

/// To price dead components
class DeadPricer {
public:
    virtual bool isDead(DateTime valueDate, double *price) const =0;
};

class ModelResetProduct {
public:
    virtual DateTimeArraySP getModelResetDates(void)=0;
};

/*************************************************/

class IGetCfDate {
    public:
    virtual void getCfDate(DateTimeArray &cfDates) = 0;
};

class ExpandableIProdCreator : virtual public IProdCreator {
public:
    static CClassConstSP const TYPE;
    virtual IProdCreatorSP expandIProdCreator(void)=0;
    // expandAll expands recursively. Returns the new root of the tree
    static IProdCreatorSP expandAll(const IProdCreatorSP &root);

private:
    static void load(CClassSP& clazz);
};
typedef smartPtr<ExpandableIProdCreator> ExpandableIProdCreatorSP;
DRLIB_END_NAMESPACE

#endif
