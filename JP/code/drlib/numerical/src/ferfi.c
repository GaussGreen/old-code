#include "imsl_inc.h"

#if defined( _MSC_VER )
#pragma warning( once : 4101 4102 4244 4305 )
#endif

#define COUNT(A)    (sizeof(A)/sizeof(Mfloat))
	/*
	 * SERIES FOR ERFI ON THE INTERVAL 0.00000E-01 TO  5.62500E-01 WITH
	 * WEIGHTED ERROR        6.81E-17 LOG WEIGHTED ERROR        16.17
	 * SIGNIFICANT FIGURES REQD. 15.17 DECIMAL PLACES REQUIRED   16.84
	 */
	static Mfloat 	lv_erfics[] = {
                -.0510281607605825074013733865176e0,
		.0976712136542976168051122672031e0,
		.0106798426748877000197021227858e0,
		.00145839261934235994760845092566e0,
		.000221395617935346452980889958716e0,
		.0000357546426953869466455481344805e0,
		.00000601305243584652659027746712369e0,
		.00000104056052819195311829805188061e0,
		.00000018393099988652242913597575563e0,
		.00000003304859580256689297257310837e0,
		.00000000601592296492422089765598882e0,
		.00000000110675054607426935593741602e0,
		.00000000020540500062873634187190224e0,
		.00000000003840485495835378474193636e0,
		.00000000000722613514301305057424678e0,
		.00000000000136709063800064215760026e0,
		.00000000000025987080985380550245075e0,
		.00000000000004960649711523937004868e0,
		.00000000000000950461236358905433088e0,
		.0000000000000018271407438754928837e0,
		.00000000000000035229350975383006662e0,
		.00000000000000006810937482440024885e0,
		.00000000000000001319990081950303068e0,
		.00000000000000000256390641344054319e0,
		.00000000000000000049902175821710612e0,
		.000000000000000000097308471941199e0,
		.00000000000000000001900781230046419e0,
		.00000000000000000000371884031926145e0,
		.00000000000000000000072866273739281e0,
		.00000000000000000000014296976677763e0,
		.00000000000000000000002808794800238e0,
		.0000000000000000000000055248115833e0,
		.00000000000000000000000108793649641e0,
		.00000000000000000000000021446095381e0,
		.0000000000000000000000000423179096e0,
		.00000000000000000000000000835807968e0,
		.00000000000000000000000000165223675e0,
		.00000000000000000000000000032688917e0,
		.00000000000000000000000000006472499e0,
		.00000000000000000000000000001282534e0,
		.00000000000000000000000000000254316e0,
		.00000000000000000000000000000050463e0,
		.0000000000000000000000000000001002e0,
		.00000000000000000000000000000001991e0};
	/*
	 * SERIES FOR ERFI2  ON THE INTERVAL 5.62500E-01 TO  8.78906E-01 WITH
	 * WEIGHTED ERROR        2.67E-17 LOG WEIGHTED ERROR        16.57
	 * SIGNIFICANT FIGURES REQD. 16.00 DECIMAL PLACES REQUIRED   17.31
	 */
	static Mfloat	lv_efi2cs[] = {
                 .438415854778045637319801779979e0,
		 .154965642852067991037772689523e0,
		 .0243489708501710908090071069528e0,
		 .00493935031686080438418833256646e0,
		 .00112758487543688711572520024555e0,
		 .000275357435254112288155751113759e0,
		 .0000702246728579480607673517810678e0,
		 .0000184588999736178576867498307331e0,
		 .00000496107288353150594118132018898e0,
		 .00000135625184942828757082118280349e0,
		 .00000037579302019082852893256314385e0,
		 .00000010526644220157780979702899318e0,
		 .00000002975375341548918629669848929e0,
		 .00000000847380696372998443740396907e0,
		 .00000000242892145161824298099995518e0,
		 .00000000070010011476225413184830288e0,
		 .00000000020277152716342503811580856e0,
		 .00000000005897920817401409607946429e0,
		 .00000000001721966703677689454268985e0,
		 .0000000000050443751878018646928754e0,
		 .00000000000148216669572317963679065e0,
		 .00000000000043668262365500941796308e0,
		 .00000000000012897453453497589196985e0,
		 .00000000000003817824080130257941171e0,
		 .00000000000001132448892721786171924e0,
		 .00000000000000336541888324047603825e0,
		 .00000000000000100187402124898581973e0,
		 .00000000000000029873322472683708689e0,
		 .00000000000000008920712569016610911e0,
		 .00000000000000002667569334469285919e0,
		 .00000000000000000798713840961047182e0,
		 .00000000000000000239435877086275627e0,
		 .00000000000000000071858222569356767e0,
		 .00000000000000000021588513175543796e0,
		 .00000000000000000006492328880032548e0,
		 .00000000000000000001954270613532739e0,
		 .00000000000000000000588779016681706e0,
		 .00000000000000000000177534308346033e0,
		 .00000000000000000000053574140436077e0,
		 .00000000000000000000016179056840626e0,
		 .00000000000000000000004889446964027e0,
		 .00000000000000000000001478630074017e0,
		 .00000000000000000000000447443704295e0,
		 .00000000000000000000000135482486302e0,
		 .00000000000000000000000041047010579e0,
		 .00000000000000000000000012442913625e0,
		 .00000000000000000000000003773932534e0,
		 .0000000000000000000000000114521671e0,
		 .00000000000000000000000000347690927e0,
		 .00000000000000000000000000105609356e0,
		 .00000000000000000000000000032092721e0,
		 .0000000000000000000000000000975659e0,
		 .00000000000000000000000000002967356e0,
		 .00000000000000000000000000000902847e0,
		 .00000000000000000000000000000274806e0,
		 .00000000000000000000000000000083675e0,
		 .00000000000000000000000000000025487e0,
		 .00000000000000000000000000000007766e0,
		 .00000000000000000000000000000002367e0};



/* Structured by FOR_STRUCT, v0.2, on 06/05/90 at 17:21:37
    Options SET: fmt=t s=n
  -----------------------------------------------------------------------
    IMSL Name:  ERFI/DERFI (Single/Double precision version)

    Computer:   FORC/SINGLE

    Revised:    November 28, 1988

    Purpose:    Evaluate the inverse error function.

    Usage:      ERFI(X)

    Arguments:
       X      - Argument for which the function value is desired.
                (Input)
       ERFI   - Function value.  (Output)

    Remark:
       Informational error:
       Type Code
         3   2  Result of ERFI(X) is accurate to less than one half
                precision because the absolute value of the argument
                is too large.

    GAMS:       C8a

    Chapter:    SFUN/LIBRARY Error Function and Related Functions

    Copyright:  1984 by IMSL, Inc.  All Rights Reserved.

    Warranty:   IMSL warrants only that IMSL testing has been applied
                to this code.  No other warranty, expressed or implied,
                is applicable.

  -----------------------------------------------------------------------
 */
#ifdef ANSI
Mfloat imsl_f_erf_inverse(Mfloat x)
#else
Mfloat imsl_f_erf_inverse(x)
	Mfloat           x;
#endif
{
	Mfloat           eps, erfi_v, x2, xabs;
	static Mint      nerfi = 0;
	static Mint      nefi2 = 0;
	static Mfloat    xsmall = 0.0;
	static Mfloat    xbig = 0.0;

	E1PSH("imsl_f_erf_inverse", "imsl_d_erf_inverse");

	erfi_v = imsl_amach(6);

	if (nerfi == 0) {
		eps = 0.1 * imsl_amach(3);
		nerfi = imsl_inits(lv_erfics, COUNT(lv_erfics), eps);
		nefi2 = imsl_inits(lv_efi2cs, COUNT(lv_efi2cs), eps);
		xsmall = sqrt(imsl_amach(3));
		eps = sqrt(imsl_amach(4) / (F_FOUR * 3.1415));
		xbig = -eps / log(1.77 * eps);
		xbig += -(xbig * log(1.77 * xbig) + eps) / (F_ONE + log(1.77 * xbig));
		xbig = F_ONE - xbig;
	}
	xabs = fabs(x);

	if (xabs >= F_ONE) {
                    /* %(L1) must be between %(R1) and %(R2),
                       but %(L1) = %(R3). */
                imsl_e1stl(1, "x");
                imsl_e1str(1, -F_ONE);
                imsl_e1str(2,  F_ONE);
		imsl_e1str(3, x);
                imsl_ermes(IMSL_FATAL, IMSL_REAL_OUT_OF_RANGE);
	} else if (xabs <= 0.75) {
		x2 = F_ZERO;
		if (xabs > xsmall)
			x2 = x * x;
		erfi_v = x * (F_ONE + imsl_csevl(32.0 * x2 / F_NINE - F_ONE, lv_erfics, nerfi));
	} else if (xabs <= 0.9375) {
		erfi_v = x * (F_ONE + imsl_csevl((512.0 * x * x - 369.0) / 81.0, lv_efi2cs,
					    nefi2));
	} else {
		erfi_v = sign(imsl_f_erfc_inverse(F_ONE - xabs), x);
		if (xabs > xbig) {
                            /* The result is accurate to less than one half
                               precision because abs(%(R1)) is greater
                               than %(R2). */
			imsl_e1str(1, x);
			imsl_e1str(2, xbig);
                        imsl_ermes(IMSL_WARNING, IMSL_LARGE_ABS_ARG_WARN);
		}
	}
	E1POP("imsl_f_erf_inverse", "imsl_d_erf_inverse");
	return (erfi_v);
}
