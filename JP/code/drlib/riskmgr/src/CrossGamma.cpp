//----------------------------------------------------------------------------
//
//   Group       : EDG Derivatives Research
//
//   Filename    : CrossGamma.cpp
//
//   Description : CrossGamma sensitivity
//
//   Author      : Mark A Robson
//
//   Date        : 16 Mar 2001
//
//
//----------------------------------------------------------------------------

#include "edginc/config.hpp"
#include "edginc/CrossGamma.hpp"
#include "edginc/Delta.hpp"
#include "edginc/SensitivityFactory.hpp"
#include "edginc/Maths.hpp"
#include "edginc/TweakGroup.hpp"
#include "edginc/ITweakableWithRespectTo.hpp"
#include "edginc/Control.hpp"
#include "edginc/Results.hpp"
#include "edginc/Untweakable.hpp"

DRLIB_BEGIN_NAMESPACE

const string CrossGamma::NAME = "CROSS_GAMMA";
const double CrossGamma::DEFAULT_SHIFT = Delta::DEFAULT_SHIFT;

/** constructor with explicit shift size */
CrossGamma::CrossGamma(double     shiftSize):
    Sensitivity(TYPE), shiftSize(shiftSize){}

/** for reflection */
CrossGamma::CrossGamma(): 
    Sensitivity(TYPE), shiftSize(DEFAULT_SHIFT){}

/** identifies the name used for storing associated results in the output*/
const string& CrossGamma::getSensOutputName() const{
    return NAME;
}
/** useful for checking internally computed x gamma against those
    generated by default using the external tweaker */
#define xDEBUG_INST_XGAMMA

/** override delta calculation to calculate cross gamma */
void CrossGamma::calculate(TweakGroup*      tweakGroup,
                           CResults*        results){
    try {
        // see if delta is asked for, and if so, use its shift size
        double deltaShift = control->getDeltaShiftSize();
        bool   deltaRequested = !Maths::isZero(deltaShift);
        if (!deltaRequested){
            control->removePacketAfterCalc(Delta::NAME);
            control->removePacketAfterCalc(Delta::SECOND_ORDER_NAME);
        }
        double shiftToUse = !deltaRequested? shiftSize: deltaShift;

        // have to do delta before we can do cross gamma
        DeltaSP delta1(new Delta(shiftToUse,
                                 getModel(),
                                 getControl()));
        // but want to avoid doing Delta if we have already calculated
        // Cross Gamma. So get list of names that we need to do
        OutputNameArrayConstSP deltaNames = hasOverrideNames()?
            OutputName::singleNameArray(toTweak):
            delta1->names(tweakGroup);
        deltaNames = OutputName::trim(deltaNames); // remove duplicates/empties
        BoolArray needDelta(deltaNames->size(), false);
        // now loop to see if result exists
        for (int i = 0; i < deltaNames->size(); i++){
            for (int j = i+1; j < deltaNames->size(); j++){
                OutputNameSP name(new OutputName((*deltaNames)[i].get(), 
                                                 (*deltaNames)[j].get()));
#ifndef DEBUG_INST_XGAMMA
                if (!results->exists(NAME, name)){
#endif
                    needDelta[i] = true;
                    needDelta[j] = true;
#ifndef DEBUG_INST_XGAMMA
                }
#endif
            }
        }
        // now build up names that we actually need for delta
        OutputNameArraySP actDeltaNames(new OutputNameArray());
        for (int j = 0; j < needDelta.size(); j++){
            if (needDelta[j]){
                actDeltaNames->push_back((*deltaNames)[j]);
            }
        }
        // code assumes that empty names => sensitivity not applicable
        // Also if only one/none delta name then no cross gamma so
        // must store not applicable
        if (!actDeltaNames->empty() || deltaNames->size() <= 1){
            // Then put them in delta1 and delta2
            delta1->storeOverrideNames(actDeltaNames);
            // set up space for the recording of what shifts we're doing
            shifts = ScalarShiftArray(1);
            // then store delta1 there
            shifts[0] = delta1;
            delta1->calculate(tweakGroup, results);
            DeltaSP delta2(new Delta(shiftToUse,
                                     getModel(),
                                     getControl()));
            
            delta2->storeOverrideNames(actDeltaNames);
            // update shifts
            shifts.push_back(delta2);
            try{
                // then call second order cross derivative calculation
                ScalarShift::calculateCrossDerivative(
                    this,
                    delta1.get(), Delta::SECOND_ORDER_NAME,
                    delta2.get(), Delta::SECOND_ORDER_NAME,
                    tweakGroup, results);
            } catch (exception&){
                shifts.resize(0); // reset shifts
                throw;
            }
            shifts.resize(0); // reset shifts
        }
    }
    catch (exception& e){
        throw ModelException(&e,  "CrossGamma::calculate");
    }
}

/** Is this sensitivity made using a discrete shift (ie a jump) or a
    an approximately continuous one.  */
bool CrossGamma::discreteShift() const{
    return false;
}

/** When calculating cross gamma, several pricings have to be done. These
    either involve a single shift or a double shift. This routine, called
    upon the Sensitivity returned from Control::getSens(), returns the
    shifts which have been made for the current pricing call */
ScalarShiftArray CrossGamma::getComponentShifts() const{
    return shifts;
}

/** Returns the shifts which define the 'area of operation of the
    shifts'. This means the names of what is going to be shifted, the
    largest shift size for each shift and the nature of the shift
    (which is captured by the type of the SensControl). The names
    should be stored so that they can be retrieved using the names()
    method.  The shifts returned must be distinct (ie not SP to the
    same object). Additionally the names within the ScalarShifts must not
    have blanks or duplicates */
ScalarShiftArray CrossGamma::definingShifts(CInstrument*   instrument,
                                            IModel*        model,
                                            Control*       control) const{
    try{
        // see if delta is asked for, and if so, use its shift size
        double deltaShift = control->getDeltaShiftSize();
        double shiftToUse = Maths::isZero(deltaShift) ? shiftSize : deltaShift;
        DeltaSP delta(new Delta(shiftToUse));
        OutputNameArraySP names;
        if (hasOverrideNames()) {
            names = OutputName::singleNameArray(toTweak);
        } else {
            // need to generate names. So set up tweak group and SensMgr
            TweakGroup tweakGroup(InstrumentSP::attachToRef(instrument),
                                  IModelSP::attachToRef(model));
            // then ask for relevant names
            names = OutputNameArraySP(delta->names(&tweakGroup).clone());
        }
        /** remove empty names or duplicates */
        names = OutputName::trim(names);
        delta->storeOverrideNames(names);
        // finally return array
        ScalarShiftArray shifts(2);
        shifts[0] = delta;
        // must return separate instances
        shifts[1] = ScalarShiftSP(delta.clone());
        return shifts;
    } catch (exception& e){
        throw ModelException(e, "CrossGamma::definingShifts");
    }
}

class CrossGammaHelper{
    /** Factory class dictates what methods of building this
        sensitivity are supported. Here we support a default + one for
        a given shift size */
    class Factory: public SensitivityFactory::IDefault,
                   public SensitivityFactory::IScalar {
    public:
        virtual Sensitivity* createDefault(){
            return new CrossGamma(CrossGamma::DEFAULT_SHIFT);
        }
        virtual Sensitivity* createScalar(double shiftSize){
            return new CrossGamma(shiftSize);
        }
    };
        
public:
    /** Invoked when Class is 'loaded' */
    static void load(CClassSP& clazz){
        clazz->setPublic(); // make visible to EAS/spreadsheet
        REGISTER(CrossGamma, clazz);
        SUPERCLASS(Sensitivity);
        IMPLEMENTS(Additive);
        IMPLEMENTS(ISpotCrossDerivative);
        EMPTY_SHELL_METHOD(defaultCrossGamma);
        FIELD(shiftSize, "How big to make the tweak");
        // register how to build our sensitivity
        SensitivityFactory::addSens(CrossGamma::NAME, 
                                    new Factory(), 
                                    new CrossGamma(CrossGamma::DEFAULT_SHIFT),
                                    ITweakableWithRespectTo<Spot>::TYPE);
    }

    static IObject* defaultCrossGamma(){
        return new CrossGamma();
    }
};

CClassConstSP const CrossGamma::TYPE = CClass::registerClassLoadMethod(
    "CrossGamma", typeid(CrossGamma), CrossGammaHelper::load);


DRLIB_END_NAMESPACE
